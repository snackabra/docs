[JSLib Reference Manual](../README.md) / [Exports](../modules.md) / SB384

# Class: SB384

SB384

## Table of contents

### Constructors

- [constructor](SB384.md#constructor)

### Properties

- [ready](SB384.md#ready)
- [sb384Ready](SB384.md#sb384ready)

### Accessors

- [exportable\_pubKey](SB384.md#exportable_pubkey)
- [hash](SB384.md#hash)
- [jwk](SB384.md#jwk)
- [key](SB384.md#key)
- [ownerChannelId](SB384.md#ownerchannelid)
- [private](SB384.md#private)
- [readyFlag](SB384.md#readyflag)
- [userId](SB384.md#userid)
- [userKeyString](SB384.md#userkeystring)

## Constructors

### constructor

• **new SB384**(`key?`, `forcePrivate?`): [`SB384`](SB384.md)

Basic (core) capability object in SB.

Like most SB classes, SB384 follows the "ready template" design
pattern: the object is immediately available upon creation,
but isn't "ready" until it says it's ready. See `Channel Class`_
example below. Getters will throw exceptions if the object
isn't sufficiently initialized. Also see Design Note [4]_.

[https://snackabra.io/jslib.html#dn-004-the-ready-pattern](https://snackabra.io/jslib.html#dn-004-the-ready-pattern)

#### Parameters

| Name | Type | Description |
| :------ | :------ | :------ |
| `key?` | `string` \| `JsonWebKey` | a jwk with which to create identity; if not provided, it will 'mint' (generate) them randomly, in other words it will default to creating a new identity ("384"). |
| `forcePrivate?` | `boolean` | if true, will force SB384 to include private key; it will throw an exception if the key is not private. If SB384 is used to mint, then it's always private. |

#### Returns

[`SB384`](SB384.md)

## Properties

### ready

• **ready**: `Promise`\<[`SB384`](SB384.md)\>

___

### sb384Ready

• **sb384Ready**: `Promise`\<[`SB384`](SB384.md)\>

## Accessors

### exportable\_pubKey

• `get` **exportable_pubKey**(): `JsonWebKey`

For 'jwk' format use cases.

#### Returns

`JsonWebKey`

___

### hash

• `get` **hash**(): `string`

Returns a unique identifier for external use, that will be unique
for any class or object that uses SB384 as it's root.

This is deterministic. Important use case is to translate a user id
into a channel id (eg the channel that any user id is inherently
the owner of).

The hash is base64 encoding of the SHA-384 hash of the public key,
taking the 'x' and 'y' fields. Note that it is slightly restricted, it only
allows [A-Za-z0-9], eg does not allow the '_' or '-' characters. This makes the
encoding more practical for end-user interactions like copy-paste. This
is accomplished by simply re-hashing until the result is valid. This 
reduces the entropy of the channel ID by a neglible amount. 

Note this is not b62 encoding, which we use for 256-bit entities. This
is still ~384 bits (e.g. x and y fields are each 384 bits, but of course
the underlying total entropy isn't that (exercise left to the reader).

NOTE: if you ever need to COMPARE hashes, the short version is that
you cannot do so in the general case: you need to use sbCrypto.compareHashWithKey()

#### Returns

`string`

___

### jwk

• `get` **jwk**(): `JsonWebKey`

#### Returns

`JsonWebKey`

___

### key

• `get` **key**(): `CryptoKey`

#### Returns

`CryptoKey`

___

### ownerChannelId

• `get` **ownerChannelId**(): `string`

ChannelID that corresponds to this, if it's an owner

#### Returns

`string`

___

### private

• `get` **private**(): `boolean`

Returns true if this is a private key, otherwise false.
Will throw an exception if the object is not ready.

#### Returns

`boolean`

___

### readyFlag

• `get` **readyFlag**(): `boolean`

#### Returns

`boolean`

___

### userId

• `get` **userId**(): `string`

Somewhat confusing at times, the string version of the user key per se is
different from "hash" (the full public key can be recovered from SBUserId).
Eg this is the public identifier.

#### Returns

`string`

___

### userKeyString

• `get` **userKeyString**(): `string`

Wire format of full info of key (eg private key).

#### Returns

`string`
