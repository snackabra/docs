!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>ue,ChannelSocket:()=>pe,MessageBus:()=>a,SB:()=>ve,SB384:()=>ye,SBCrypto:()=>ne,SBMessage:()=>ge,SBObjectHandle:()=>fe,Snackabra:()=>be,arrayBuffer32ToBase62:()=>N,arrayBufferToBase62:()=>$,arrayBufferToBase64:()=>_,assemblePayload:()=>Z,base62ToArrayBuffer:()=>H,base62ToArrayBuffer32:()=>U,base62ToBase64:()=>F,base64ToArrayBuffer:()=>C,base64ToBase62:()=>J,compareBuffers:()=>R,decodeB64Url:()=>Q,encodeB64Url:()=>Y,encryptedContentsMakeBinary:()=>y,extractPayload:()=>X,extractPayloadV1:()=>q,getRandomValues:()=>d,isBase62Encoded:()=>W,isSBKey:()=>te,jsonParseWrapper:()=>V,partition:()=>z,sbCrypto:()=>he,version:()=>r});var n=function(e,t,n,r){var o,s=arguments.length,a=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(o=e[i])&&(a=(s<3?o(a):s>3?o(t,n,a):o(t,n))||a);return s>3&&a&&Object.defineProperty(t,n,a),a};const r="2.0.0-alpha.5 (build 20)";var o=!0,s=!1;class a{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}function i(e,t){return new Promise(((n,r)=>{try{fetch(e,t??{method:"GET"}).then((e=>{n(e)})).catch((e=>{const t=`[SBFetch] Error (fetch through a reject, might be normal): ${e}`;console.warn(t),r(t)}))}catch(e){const t=`[SBFetch] Error (fetch exception, might be normal operation): ${e}`;console.warn(t),r()}}))}function c(e){return e instanceof Error?e:new Error(String(e))}function l(e,t){throw new Error("[_sb_exception] << SB lib error ("+e+": "+t+") >>")}function h(e,t){if(!e)throw new Error(`[_sb_assert] << SB assertion error: ${t} >>`)}function y(e){try{let t,n;if(s&&(console.log("=+=+=+=+ processing content"),console.log(e.content.constructor.name)),"string"==typeof e.content)try{t=C(decodeURIComponent(e.content))}catch(e){throw new Error("EncryptedContents is string format but not base64 (?)")}else{const n=e.content.constructor.name;h("ArrayBuffer"===n||"Uint8Array"===n,"undetermined content type in EncryptedContents object"),t=e.content}if(s&&console.log("=+=+=+=+ processing nonce"),"string"==typeof e.iv)s&&(console.log("got iv as string:"),console.log(structuredClone(e.iv))),n=C(decodeURIComponent(e.iv)),s&&(console.log("this was turned into array:"),console.log(structuredClone(n)));else if("Uint8Array"===e.iv.constructor.name||"ArrayBuffer"===e.iv.constructor.name)s&&console.log("it's an array already"),n=new Uint8Array(e.iv);else{s&&console.log("probably a dictionary");try{n=new Uint8Array(Object.values(e.iv))}catch(t){o&&(console.error("ERROR: cannot figure out format of iv (nonce), here's the input object:"),console.error(e.iv)),h(!1,"undetermined iv (nonce) type, see console")}}return s&&(console.log("decided on nonce as:"),console.log(n)),h(12==n.length,`encryptedContentsMakeBinary(): nonce should be 12 bytes but is not (${n.length})`),{content:t,iv:n}}catch(e){const t=`encryptedContentsMakeBinary() failed: ${e}`;throw o&&console.error(t),new Error(t)}}function d(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{h(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}const g=/([A-Za-z0-9+/_\-=]{64})([01]{42})/,u=/^([A-Za-z0-9+/_\-=]*)$/;function p(e){return u.test(e)}const f=p,w=[],b=[],v=[],S="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",m=S+"+/",k=S+"-_",K="=",E=16383;for(let e=0,t=m.length;e<t;++e)w[e]=m[e],b[e]=k[e],v[m.charCodeAt(e)]=e;function C(e){if(!p(e))throw new Error(`invalid character in string '${e}'`);let t;switch(e.length%4){case 2:e+="==";break;case 3:e+="="}const[n,r]=function(e){const t=e.length;let n=e.indexOf(K);return-1===n&&(n=t),[n,n===t?0:4-n%4]}(e),o=new Uint8Array(function(e,t){return 3*(e+t)/4-t}(n,r));let s=0;const a=r>0?n-4:n;let i;for(i=0;i<a;i+=4)t=v[e.charCodeAt(i)]<<18|v[e.charCodeAt(i+1)]<<12|v[e.charCodeAt(i+2)]<<6|v[e.charCodeAt(i+3)],o[s++]=t>>16&255,o[s++]=t>>8&255,o[s++]=255&t;return 2===r&&(t=v[e.charCodeAt(i)]<<2|v[e.charCodeAt(i+1)]>>4,o[s++]=255&t),1===r&&(t=v[e.charCodeAt(i)]<<10|v[e.charCodeAt(i+1)]<<4|v[e.charCodeAt(i+2)]>>2,o[s++]=t>>8&255,o[s++]=255&t),o}function B(e,t){return e[t>>18&63]+e[t>>12&63]+e[t>>6&63]+e[63&t]}function A(e,t,n,r){let o;const s=new Array((r-n)/3);for(let a=n,i=0;a<r;a+=3,i++)o=(t.getUint8(a)<<16&16711680)+(t.getUint8(a+1)<<8&65280)+(255&t.getUint8(a+2)),s[i]=B(e,o);return s.join("")}v["-".charCodeAt(0)]=62,v["_".charCodeAt(0)]=63;const j=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function R(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=j(e),r=j(t);if(n.byteLength!==r.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==r.getUint8(e))return!1;return!0}function _(e,t="url"){if(null==e)return l("L893","arrayBufferToBase64() -> null paramater"),"";{const n=j(e),r=n.byteLength,o=r%3,s=r-o,a=new Array(Math.floor(s/E)+Math.sign(o)),i="url"==t?b:w,c="";let l=0;for(let e=0;e<s;e+=E)a[l++]=A(i,n,e,e+E>s?s:e+E);if(1===o){const e=n.getUint8(r-1);a[l]=i[e>>2]+i[e<<4&63]+c+c}else if(2===o){const e=(n.getUint8(r-2)<<8)+n.getUint8(r-1);a[l]=i[e>>10]+i[e>>4&63]+i[e<<2&63]+c}return a.join("")}}const O="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",I=/^(a32\.)?[0-9A-Za-z]{43}$/,P=/^[0-9a-zA-Z]*$/,T=new Map([[32,43],[16,22],[8,11],[4,6]]),M=new Map(Array.from(T,(([e,t])=>[t,e]))),D=Array.from(M.keys()).sort(((e,t)=>e-t));function x(e,t){if(e.byteLength!==t||!T.has(t))throw new Error("[arrayBufferToBase62] Decoding error");let n="";for(let t=BigInt("0x"+Array.from(new Uint8Array(e)).map((e=>e.toString(16).padStart(2,"0"))).join(""));t>0n;t/=62n)n=O[Number(t%62n)]+n;return n.padStart(T.get(t),"0")}function $(e){let t=e.byteLength;if(t%4!=0)throw new Error("[arrayBufferToBase62] Must be multiple of 4 bytes (32 bits).");let n=0,r="";for(;t>0;){let o=2**Math.min(Math.floor(Math.log2(t)),5);r+=x(e.slice(n,n+o),o),n+=o,t-=o}return r}function L(e,t){let n=0n;try{for(let t=0;t<e.length;t++)n=62n*n+BigInt(O.indexOf(e[t]));if(n>2n**BigInt(8*t)-1n)throw new Error(`base62ToArrayBuffer: value exceeds ${8*t} bits.`);const r=new ArrayBuffer(t),o=new DataView(r);for(let e=0;e<t/4;e++){const r=Number(BigInt.asUintN(32,n));o.setUint32(4*(t/4-e-1),r),n>>=32n}return r}catch(e){throw console.error("[_base62ToArrayBuffer] Error: ",e),e}}function H(e){if(!P.test(e))throw new Error("base62ToArrayBuffer32: must be alphanumeric (0-9A-Za-z).");let t,n=0,r=0,o=43,s=new Uint8Array(e.length);try{for(;n<e.length;){if(t=D.filter((t=>t<=e.length-n)).pop(),o<43&&t>=o)throw new Error("cannot decypher b62 string (incorrect length)");o=t;let a=e.slice(n,n+t);const i=new Uint8Array(L(a,M.get(t)));s.set(i,r),n+=t,r+=i.byteLength}return s.buffer.slice(0,r)}catch(e){throw console.error("[base62ToArrayBuffer] Error:",e),e}}function U(e){if(!I.test(e))throw new Error(`base62ToArrayBuffer32: string must match: ${I}, value provided was ${e}`);return H(e)}function N(e){if(32!==e.byteLength)throw new Error("arrayBufferToBase62: buffer must be exactly 32 bytes (256 bits).");return $(e)}function F(e){return _(U(e))}function J(e){return $(C(e))}function W(e){return I.test(e)}function G(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}function z(e,t){throw`partition() not tested on TS yet - (${e}, ${t})`}function V(e,t){for(;e&&"string"==typeof e;)try{e=JSON.parse(e)}catch(n){throw new Error(`JSON.parse() error${t?` at ${t}`:""}: ${n}\nString (possibly nested) was: ${e}`)}return e}function q(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=V((new TextDecoder).decode(e.slice(4,4+t)),"L476");let r=4+t;const o={};for(const t in n)o.key&&(o[t]=e.slice(r,r+n[t]),r+=n[t]);return o}catch(e){return console.error(e),{}}}function Z(e){try{const t={version:"002"};let n=0,r=0;for(const o in e)n++,t[n.toString()]={name:o,start:r,size:e[o].byteLength},r+=e[o].byteLength;const o=(new TextEncoder).encode(JSON.stringify(t)),s=new Uint32Array([o.byteLength]);let a=G(new Uint8Array(s.buffer),new Uint8Array(o));for(const t in e)a=G(new Uint8Array(a),e[t]);return a}catch(e){return console.error(e),null}}function X(e){try{const t=new Uint32Array(e.slice(0,4))[0],n=V((new TextDecoder).decode(e.slice(4,4+t)),"L533"),r=4+t;switch(n.version||(n.version="001"),n.version){case"001":return q(e);case"002":{const t=[];for(let o=1;o<Object.keys(n).length;o++){const s=o.toString();if(n[s]){const o=n[s].start,a=n[s].size;t[n[s].name]=e.slice(r+o,r+o+a)}else console.log(`found nothing for index ${o}`)}return t}default:throw new Error("Unsupported payload version ("+n.version+") - fatal")}}catch(e){throw new Error("extractPayload() exception ("+e+")")}}function Y(e){return e.replaceAll("+","-").replaceAll("/","_")}function Q(e){const t=(e=e.replaceAll("-","+").replaceAll("_","/")).length%4;if(t){if(1===t)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");e+=new Array(5-t).join("=")}return e}var ee;function te(e){return e&&Object.values(ee).includes(e.prefix)}!function(e){e.SBPublicKey="PNk2",e.SBAES256Key="X881",e.SBPrivateKey="Xj3p"}(ee||(ee={}));class ne{#t=new Map;SBKeyToJWK(e){if(!te(e))return e;switch(e.prefix){case ee.SBPublicKey:return{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:e.x,y:e.y};case ee.SBPrivateKey:return{crv:"P-384",d:e.d,ext:!0,key_ops:["deriveKey"],kty:"EC",x:e.x,y:e.y};case ee.SBAES256Key:return{k:e.k,alg:"A256GCM",key_ops:["encrypt","decrypt"],kty:"oct"};default:throw new Error(`SBKeyToJWK() - unknown key prefix: ${e.prefix}`)}}JWKToSBKey(e,t=!1){if(e){if("oct"===e.kty&&"A256GCM"===e.alg&&e.k&&43===e.k.length)return{prefix:ee.SBAES256Key,k:J(e.k)};if("EC"===e.kty&&"P-384"===e.crv&&e.x&&e.y){if(64!==e.x.length||64!==e.y.length)return;return e.d&&64===e.d.length&&!t?{prefix:ee.SBPrivateKey,x:e.x,y:e.y,d:e.d}:{prefix:ee.SBPublicKey,x:e.x,y:e.y}}}}SBKeyToString(e){const t=e.prefix;switch(t){case ee.SBAES256Key:return t+J(e.k);case ee.SBPublicKey:{const n=e,r=new Uint8Array(96);return r.set(C(n.x),0),r.set(C(n.y),48),t+$(r)}case ee.SBPrivateKey:{const n=e,r=new Uint8Array(144);return r.set(C(n.x),0),r.set(C(n.y),48),r.set(C(n.d),96),t+$(r)}default:throw new Error("Unknown SBKey type.")}}JWKToSBUserId(e){const t=this.JWKToSBKey(e,!0);return t?this.SBKeyToString(t):void 0}StringToSBKey(e){try{if(e.length<4)return;const t=e.slice(0,4),n=e.slice(4);switch(t){case ee.SBAES256Key:{if(43!==n.length)return;const e=H(n);return{prefix:ee.SBAES256Key,k:_(e)}}case ee.SBPublicKey:{const e=H(n);if(96!==e.byteLength)return;return{prefix:ee.SBPublicKey,x:_(e.slice(0,48)),y:_(e.slice(48,96))}}case ee.SBPrivateKey:{const e=H(n);if(144!==e.byteLength)return;return{prefix:ee.SBPrivateKey,x:_(e.slice(0,48)),y:_(e.slice(48,96)),d:_(e.slice(96,144))}}default:return}}catch(e){return void console.error("StringToSBKey() - malformed input, exception: ",e)}}StringToJWK(e){const t=this.StringToSBKey(e);if(t)return this.SBKeyToJWK(t)}async addKnownKey(e){try{if(!e)return;if(te(e)&&(e=this.SBKeyToJWK(e)),"string"==typeof e){const t=await he.sb384Hash(e);if(!t)return;if(this.#t.has(t))o&&console.log(`addKnownKey() - key already known: ${t}, skipping upgrade check`);else{const n={hash:t,jwk:e,key:await he.importKey("jwk",e,"ECDH",!0,["deriveKey"])};this.#t.set(t,n)}}else if(e instanceof ye){await e.ready;const t=e.hash,n={hash:t,jwk:e.jwk,key:e.key};this.#t.set(t,n)}else{if(!(e instanceof CryptoKey))throw new Error("addKnownKey() - invalid key type (must be string or SB384-derived)");{const t=await this.sb384Hash(e);if(!t)return;if(!this.#t.has(t)){const n={hash:t,jwk:await he.exportKey("jwk",e),key:e};this.#t.set(t,n)}}}}catch(t){throw console.error("**** addKnownKey() - key / exception:",e,t),t}}lookupKeyGlobal(e){return this.#t.get(e)}generateIdKey(e){return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),r=e.slice(32);t({id_binary:n,key_material:r})}))}catch(e){n(e)}}))}extractPubKey(e){try{const t={...e};return delete t.d,delete t.dp,delete t.dq,delete t.q,delete t.qi,t.key_ops=[],t}catch(e){return console.error(e),null}}async#n(e){try{const t=160;let n=0,r=_(e);for(;!P.test(r);){if(n++>t)throw new Error(`generateChannelHash() - exceeded ${t} iterations:`);r=_(e=await crypto.subtle.digest("SHA-384",e))}return _(e)}catch(t){throw console.error("sb384Hash() failed",t),console.error("tried working from channelBytes:"),console.error(e),new Error(`sb384Hash() exception (${t})`)}}async#r(e,t){let n=0,r=_(e);for(;r!==t;){if(n++>160)return!1;r=_(e=await crypto.subtle.digest("SHA-384",e))}return!0}async sb384Hash(e){if(e instanceof CryptoKey&&(e=await this.exportKey("jwk",e).catch((()=>{}))),e){if(e&&e.x&&e.y){const t=G(C(Q(e.x)),C(Q(e.y)));return await this.#n(t)}o&&console.error("[sb384Hash] invalid JsonWebKey (missing x and/or y)",e)}}async compareHashWithKey(e,t){if(!e||!t)return!1;let n=t.x,r=t.y;if(!n||!r)try{const e=V(t,"L1787");e.x&&(n=e.x),e.y&&(r=e.y)}catch{return!1}const o=G(C(Q(n)),C(Q(r)));return await this.#r(o,e)}async verifyChannelId(e,t){return await this.compareHashWithKey(t,e)}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new Error("generateKeys() exception ("+e+")")}}async importKey(e,t,n,r,s){try{let o;const a={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new Error("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),o=await crypto.subtle.importKey("jwk",e,a[n],r,s),"EC"===e.kty&&this.addKnownKey(o)}else o=await crypto.subtle.importKey(e,t,a[n],r,s);return o}catch(a){const i=`... importKey() error: ${a}:`;throw o&&(console.error(i),console.log(e),console.log(t),console.log(n),console.log(r),console.log(s)),new Error(i)}}async exportKey(e,t){return crypto.subtle.exportKey(e,t).catch((()=>{o&&console.warn("... exportKey() protested, this just means we treat this as undefined")}))}deriveKey(e,t,n,r,o){return new Promise((async(s,a)=>{const i={AES:{name:"AES-GCM",length:256},HMAC:{name:"HMAC",hash:"SHA-256",length:256}};try{s(await crypto.subtle.deriveKey({name:"ECDH",public:t},e,i[n],r,o))}catch(s){console.error(s,e,t,n,r,o),a(s)}}))}encrypt(e,t,n,r="encryptedContents"){return new Promise((async(o,s)=>{try{null===e&&s(new Error("no contents"));const a=n&&null!==n?n:crypto.getRandomValues(new Uint8Array(12));"string"==typeof e&&(e=(new TextEncoder).encode(e));const i=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},t,e);o("encryptedContents"===r?{content:_(i),iv:_(a)}:i)}catch(e){s(e)}}))}wrap(e,t,n){return new Promise((r=>{let o;o="string"===n?he.str2ab(t):t,he.encrypt(o,e).then((e=>{r(e)}))}))}unwrap(e,t,n){return new Promise((async(r,s)=>{try{const{content:o,iv:s}=y(t),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},e,o);"string"===n?r((new TextDecoder).decode(a)):"arrayBuffer"===n&&r(a)}catch(e){o&&console.error(`unwrap(): cannot unwrap/decrypt - rejecting: ${e}`),s(e)}}))}sign(e,t){return new Promise((async(n,r)=>{try{const o=(new TextEncoder).encode(t);let s;try{s=await crypto.subtle.sign("HMAC",e,o),n(_(s))}catch(e){r(e)}}catch(e){r(e)}}))}verify(e,t,n){return new Promise(((r,o)=>{try{crypto.subtle.verify("HMAC",e,C(t),he.str2ab(n)).then((e=>{r(e)}))}catch(e){o(c(e))}}))}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}compareKeys(e,t){return null!=e&&null!=t&&"object"==typeof e&&"object"==typeof t&&e.x===t.x&&e.y===t.y}async channelKeyStringsToCryptoKeys(e){return new Promise((async(t,n)=>{let r=V(e.ownerKey,"2593");Promise.all([he.importKey("jwk",r,"ECDH",!0,[]),he.importKey("jwk",V(e.encryptionKey,"2296"),"AES",!0,["encrypt","decrypt"]),he.importKey("jwk",V(e.signKey,"2597"),"ECDH",!0,["deriveKey"]),he.importKey("jwk",he.extractPubKey(V(e.signKey,"2598")),"ECDH",!0,[])]).then((async e=>{o&&console.log("++++++++ readyPromise() processed first batch of keys");const n=e[0],r=e[1],s=e[2],a=e[3];t({ownerKey:n,encryptionKey:r,signKey:s,publicSignKey:a})})).catch((e=>{console.error(`readyPromise(): failed to import keys: ${e}`),n(e)}))}))}}function re(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=r.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function oe(e,t,n){if(n&&n.get){let r=n.get;n.get=function(){const n=e.constructor.name;`${n}ReadyFlag`in this&&h(this.readyFlag,`${t} getter accessed but object ${n} not 'ready' (fatal)`);const o=r.call(this);return h(null!=o,`${t} getter accessed in object type ${n}, which reports 'ready' but return value is NULL (fatal)`),o}}}const se=["SBMessage","SBObjectHandle","SBChannelHandle"],ae=Symbol("SBChannelHandle"),ie=Symbol.for("SBMessage"),ce=Symbol.for("SBObjectHandle");function le(e,t){switch(t){case"SBMessage":return ie in e;case"SBObjectHandle":case"SBChannelHandle":return ce in e;default:return!1}}const he=new ne;class ye{ready;sb384Ready;#o=!1;#s;#a;#i;#c;constructor(e,t){this.ready=new Promise((async(n,r)=>{try{if(e)if(e instanceof Object&&"kty"in e){if(e.d)this.#s=!0;else if(this.#s=!1,t)throw new Error("ERROR creating SB384 object: key provided is not the requested private");this.#i=e,this.#a=await he.importKey("jwk",this.#i,"ECDH",!0,["deriveKey"]).catch((e=>{throw e}))}else{if("string"!=typeof e)throw new Error("ERROR creating SB384 object: invalid key (must be a JsonWebKey, SBUserId, or omitted)");{const n=he.StringToSBKey(e);if(!n)throw new Error("ERROR creating SB384 object: failed to import SBUserId");if(n.prefix===ee.SBPublicKey){if(this.#s=!1,t)throw new Error("ERROR creating SB384 object: key provided is not the requested private")}else{if(n.prefix!==ee.SBPrivateKey)throw new Error("ERROR creating SB384 object: invalid key (neither public nor private)");this.#s=!0}this.#i=he.SBKeyToJWK(n),this.#s?this.#a=await he.importKey("jwk",this.#i,"ECDH",!0,["deriveKey"]):this.#a=await he.importKey("jwk",this.#i,"ECDH",!0,[])}}else{s&&console.log("SB384() - generating new key pair");const e=await he.generateKeys();this.#s=!0,this.#a=e.privateKey,this.#i=await he.exportKey("jwk",this.#a),h(this.#i,"ERROR creating SB384 object: failed to export key to jwk format")}this.#c=await he.sb384Hash(this.#i),s&&console.log("SB384() - constructor wrapping up",this),he.addKnownKey(this),this.#o=!0,n(this)}catch(e){r("ERROR creating SB384 object failed: "+c(e))}})),this.sb384Ready=this.ready}get readyFlag(){return this.#o}get private(){return this.#s}get hash(){return this.#c}get ownerChannelId(){if(!this.private)throw new Error("ownerChannelId() - not a private key, cannot be an owner key");return this.hash}get jwk(){return this.#i}get key(){return this.#a}get exportable_pubKey(){return he.extractPubKey(this.#i)}get userKeyString(){if(!this.private)throw new Error("userKeyString() - not a private key, there is no userKeyString");return he.SBKeyToString(he.JWKToSBKey(this.#i))}get userId(){return he.SBKeyToString(he.JWKToSBKey(this.jwk,!0))}}n([re],ye.prototype,"readyFlag",null),n([re,oe],ye.prototype,"private",null),n([re,oe],ye.prototype,"hash",null),n([re,oe],ye.prototype,"ownerChannelId",null),n([re,oe],ye.prototype,"jwk",null),n([re,oe],ye.prototype,"key",null),n([re,oe],ye.prototype,"exportable_pubKey",null),n([re,oe],ye.prototype,"userKeyString",null),n([re,oe],ye.prototype,"userId",null);class de extends ye{ready;sbChannelKeysReady;#l=!1;#h=!1;#y;#d;#g;#u;#p;#f;constructor(e,t,n){switch(e){case"handle":{const e=t;super(e.userKeyString,!0),this.#u=e.channelServer,this.#u&&"/"===this.#u[this.#u.length-1]&&(this.#u=this.#u.slice(0,-1)),this.#p=e.channelId}break;case"jwk":super(t,!0);break;case"new":super();break;default:throw new Error("Illegal parameters")}this.ready=new Promise((async(t,r)=>{try{if(await this.sb384Ready,"jwk"!==e&&"new"!==e||(this.#p=this.hash,this.#h=!0),n)o&&console.log("++++ SBChannelKeys initialized from key strings"),await this.#w(await he.channelKeyStringsToCryptoKeys(n));else if(this.#u)o&&console.log("++++ SBChannelKeys initialized from channel server"),await i(this.#u+"/api/room/"+this.#p+"/getChannelKeys",{method:"GET",headers:{"Content-Type":"application/json"}}).then((e=>(e.ok||r("ChannelEndpoint(): failed to get channel keys (network response not ok)"),e.json()))).then((async e=>{e.error&&r("ChannelEndpoint(): failed to get channel keys (error in response)"),await this.#w(await he.channelKeyStringsToCryptoKeys(e)),this.#l=!0,t(this)})).catch((e=>{throw e}));else{if(o&&console.log("++++ SBChannelKeys initialized from scratch"),this.#d)throw new Error("newKeys() called but channelData already exists (already initialized)");this.#h=!0;const e=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);this.#g=e;const t=await crypto.subtle.exportKey("jwk",e),n=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"]),r=await crypto.subtle.exportKey("jwk",n.privateKey);this.#d={roomId:this.hash,ownerKey:JSON.stringify(this.exportable_pubKey),encryptionKey:JSON.stringify(t),signKey:JSON.stringify(r)}}this.#l=!0,t(this)}catch(e){r("ERROR creating SBChannelKeys object failed: "+c(e))}})),this.sbChannelKeysReady=this.ready}async#w(e){s&&console.log("[channel.#setKeys] set channelkeys to 'k':",e),this.#y=e,h(e,"Channel.importKeys: no channel keys (?)"),h(this.#y.publicSignKey,"Channel.importKeys: no public sign key (?)"),h(this.private&&this.key,"setKeys(): no private key (?)"),this.#f=await he.deriveKey(this.key,this.#y.publicSignKey,"HMAC",!1,["sign","verify"])}get readyFlag(){return this.#l}get encryptionKey(){return this.#g}get channelSignKey(){return this.#f}get owner(){return this.#h}get channelData(){return this.#d}get keys(){return this.#y}get channelId(){return this.#p}get channelServer(){return this.#u}set channelServer(e){h(!this.#u,"ChannelServer already set on this SBChannelKeys object - can't change"),this.#u=e}}n([re,oe],de.prototype,"readyFlag",null),n([re,oe],de.prototype,"encryptionKey",null),n([re,oe],de.prototype,"channelSignKey",null),n([re,oe],de.prototype,"owner",null),n([re,oe],de.prototype,"channelData",null),n([re,oe],de.prototype,"keys",null),n([re,oe],de.prototype,"channelId",null),n([re,oe],de.prototype,"channelServer",null);class ge{channel;[ie]=!0;ready;contents;#g;#b;MAX_SB_BODY_SIZE=98304;constructor(e,t="",n){this.channel=e,this.contents="string"==typeof t?{encrypted:!1,isVerfied:!1,contents:t,sign:"",image:"",imageMetaData:{}}:{encrypted:!1,isVerfied:!1,contents:"",sign:"",image:t.image,imageMetaData:t.imageMetaData};let r=this.contents,o=JSON.stringify(r);n&&(this.#b=he.extractPubKey(n)),h(o.length<this.MAX_SB_BODY_SIZE,`SBMessage(): body must be smaller than ${this.MAX_SB_BODY_SIZE/1024} KiB (we got ${o.length/1024})})`),this.ready=new Promise((t=>{e.channelReady.then((async()=>{this.contents.senderUserId=this.channel.userId,this.contents.sender_pubKey=this.channel.exportable_pubKey;const e=this.channel.channelSignKey,n=he.sign(e,r.contents),o=he.sign(e,this.contents.image),s=he.sign(e,JSON.stringify(this.contents.imageMetaData));if(this.#b)this.#g=await he.deriveKey(this.channel.key,await he.importKey("jwk",this.#b,"ECDH",!0,[]),"AES",!1,["encrypt","decrypt"]);else{const e=this.channel.keys.lockedKey;console.log("==== SBMessage() picking what key to use for channel (and this is channel.keys.lockedKey):",this.channel,e),this.#g=e||this.channel.keys.encryptionKey}Promise.all([n,o,s]).then((e=>{this.contents.sign=e[0],this.contents.image_sign=e[1],this.contents.imageMetadata_sign=e[2],this.contents.imgObjVersion="2",t(this)}))}))}))}get encryptionKey(){return this.#g}get sendToPubKey(){return this.#b}send(){return new Promise(((e,t)=>{this.ready.then((()=>{this.channel.send(this).then((n=>{"success"===n?e(n):t(n)}))}))}))}}n([oe],ge.prototype,"encryptionKey",null);class ue extends de{ready;channelReady;#v=!1;motd="";locked=!1;adminData;verifiedGuest=!1;#S="";constructor(e,t,n){let r;if("object"==typeof e&&"channelId"in e&&"userKeyString"in e?(h(!t&&!n,"If you pass a handle, you cannot pass other parameters"),r=e):(console.warn("Deprecated channel constructor used, please update your code"),h(t&&n,"If first parameter is SBServer, you must also pass both userKey and channelId"),r=function(e,t,n){const r=he.JWKToSBKey(t);h(r&&r.prefix===ee.SBPrivateKey,"Unable to import JWK (keys)");const o=he.SBKeyToString(r);return h(o,"Unable to import JWK (keys)"),{channelId:n,userKeyString:o,channelServer:e.channel_server}}(e,t,n)),!r.channelServer)throw new Error("Channel(): no channel server provided");super("handle",r),this.ready=this.sbChannelKeysReady.then((()=>(this.#v=!0,this))).catch((e=>{throw e})),this.channelReady=this.ready}get readyFlag(){return this.#v}get api(){return this}async#m(e,t){return o&&console.log("#callApi:",e),this.#v||(s&&console.log("ChannelApi.#callApi: channel not ready (we will wait)"),await this.channelReady),new Promise((async(n,r)=>{this.channelId||r("ChannelApi.#callApi: no channel ID (?)"),await this.ready;let o="";const s=(new Date).getTime().toString();o=s+"."+await he.sign(this.channelSignKey,s);let a={method:"POST",headers:{"Content-Type":"application/json",authorization:o}},l={userId:this.userId,channelID:this.channelId,...t};a.body=l,await this.ready,i(this.channelServer+"/api/room/"+this.channelId+e,a).then((async e=>{const t=await e.json();if(!e.ok||t.error){let n="Network or Server error on Channel API call";e.status&&(n+=" ["+e.status+"]"),t.error&&(n+=": "+t.error),r(new Error(n))}else n(t)})).catch((e=>{r("ChannelApi (SBFetch) Error [2]: "+c(e))}))}))}async deCryptChannelMessage(e,t){const n=g.exec(e),r=this.keys;let s=r.lockedKey?r.lockedKey:r.encryptionKey;if(n){let e,a={type:"encrypted",channelID:n[1],timestampPrefix:n[2],_id:n[1]+n[2],encrypted_contents:y(t)};try{e=await he.unwrap(s,a.encrypted_contents,"string")}catch(t){if(s!==r.lockedKey){const e="ERROR: cannot decrypt message with either locked or unlocked key";return void(o&&console.error(e))}try{s=r.encryptionKey,e=await he.unwrap(s,a.encrypted_contents,"string")}catch(e){const t="ERROR: cannot decrypt message with either locked or unlocked key";return void(o&&console.error(t))}}let i={...a,...V(e,"L1977")};if(i.contents&&(i.text=i.contents),i.user={name:i.sender_username?i.sender_username:"Unknown",_id:i.sender_pubKey},i.verificationToken&&!i.sender_pubKey)return void(o&&console.error("ERROR: message with verification token is lacking sender identity (cannot be verified)."));const c=await he.importKey("jwk",i.sender_pubKey,"ECDH",!0,[]),l=await he.deriveKey(r.signKey,c,"HMAC",!1,["sign","verify"]);return await he.verify(l,i.sign,i.contents)?(!0===i.whispered&&console.error("ERROR: whisper not yet implemented in SB 2.0"),i):(console.error("***** signature is NOT correct for message (rejecting)"),void(o&&(console.log("verifyKey:",Object.assign({},l)),console.log("m2.sign",Object.assign({},i.sign)),console.log("m2.contents",structuredClone(i.contents)),console.log("Message:",Object.assign({},i)))))}return console.error("++++++++ #processMessage: ERROR - cannot parse channel ID / timestamp, invalid message"),void(o&&(console.log(Object.assign({},e)),console.log(Object.assign({},t))))}getLastMessageTimes(){throw new Error("Channel.getLastMessageTimes(): not supported in 2.0 yet")}getOldMessages(e=100,t=!1){return new Promise((async(n,r)=>{this.channelId||r("Channel.getOldMessages: no channel ID (?)"),this.#v||(o&&console.log("Channel.getOldMessages: channel not ready (we will wait)"),await this.channelReady);let a="";t&&(a="&cursor="+this.#S),i(this.channelServer+"/"+this.channelId+"/oldMessages?currentMessagesLength="+e+a,{method:"GET"}).then((async e=>(e.ok||r(new Error("Network response was not OK")),e.json()))).then((e=>{o&&(console.log("getOldMessages"),console.log(e)),Promise.all(Object.keys(e).filter((t=>e[t].hasOwnProperty("encrypted_contents"))).map((t=>this.deCryptChannelMessage(t,e[t].encrypted_contents)))).then((e=>e.filter((e=>Boolean(e))))).then((e=>{let t=e[e.length-1];t&&(this.#S=t._id||t.id||""),s&&console.log(e),n(e)})).catch((e=>{const t=`Channel.getOldMessages(): failed to decrypt messages: ${e}`;console.error(t),r(t)}))})).catch((e=>{const t=`Channel.getOldMessages(): SBFetch failed: ${e}`;console.error(t),r(t)}))}))}send(e){return Promise.reject("Channel.send(): abstract method, must be implemented in subclass")}updateCapacity(e){return this.#m("/updateRoomCapacity?capacity="+e)}getCapacity(){return this.#m("/getRoomCapacity")}getStorageLimit(){return this.#m("/getStorageLimit")}getMother(){return this.#m("/getMother")}getJoinRequests(){return this.#m("/getJoinRequests")}isLocked(){return new Promise((e=>this.#m("/roomLocked").then((t=>{this.locked=!0===t.locked,e(this.locked)}))))}setMOTD(e){return this.#m("/motd",{motd:e})}getAdminData(){return this.#m("/getAdminData")}downloadData(){return new Promise(((e,t)=>{this.#m("/downloadData").then((t=>{console.log("From downloadData:"),console.log(t),Promise.all(Object.keys(t).filter((e=>{const n=new RegExp(this.channelId);if(e.match(n)){const n=V(t[e],"L3318");if(n.hasOwnProperty("encrypted_contents"))return o&&console.log("Received message: ",n),n}})).map((e=>{const n=V(t[e],"L3327");return s&&console.log(e,n.encrypted_contents,this.keys),this.deCryptChannelMessage(e,n.encrypted_contents)}))).then((e=>e.filter((e=>Boolean(e))))).then((n=>{let r={};n.forEach((e=>{if(!e.control&&e.imageMetaData.imageId){const t=n.find((t=>t.id&&t.id==e.imageMetaData.imageId)),o=n.find((t=>t.id&&t.id==e.imageMetaData.previewId));r[`${e.imageMetaData.imageId}.f`]=t?.verificationToken,r[`${e.imageMetaData.previewId}.p`]=o?.verificationToken}})),e({storage:r,channel:t})}))})).catch((e=>{t(e)}))}))}uploadChannel(e){return this.#m("/uploadRoom",e)}authorize(e,t){return this.#m("/authorizeRoom",{roomId:this.channelId,SERVER_SECRET:t,ownerKey:e})}postPubKey(e){throw new Error("postPubKey() deprecated")}storageRequest(e){return this.#m("/storageRequest?size="+e)}lock(e){return console.warn("WARNING: lock() on channel api is in the process of being updated and tested ..."),new Promise((async(t,n)=>{(this.locked||this.keys.lockedKey)&&n(new Error("lock(): channel already locked (rotating key not yet supported")),this.owner||n(new Error("lock(): only owner can lock channel"));const r=e||await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),s=await crypto.subtle.exportKey("jwk",r);this.#m("/lockRoom").then((e=>{!0===e.locked?this.acceptVisitor(this.userId).then((()=>{o&&console.log("lock(): succeded with lock key:",s),this.locked=!0,this.keys.lockedKey=r,t({locked:this.locked,lockedKey:s})})).catch((e=>{n(new Error(`was unable to accept 'myself': ${e}`))})):n(new Error(`lock(): failed to lock channel, did not receive confirmation. (data: ${e})`))})).catch((e=>{n(new Error(`api call to /lockRoom failed ${e}`))}))}))}acceptVisitor(e){return console.warn("WARNING: acceptVisitor() on channel api has not been tested/debugged fully .."),new Promise((async(t,n)=>{const r=he.StringToJWK(e);r||n(new Error("acceptVisitor(): could not determine public key from SBUserId (should be able to)"));const o=await he.deriveKey(this.key,await he.importKey("jwk",r,"ECDH",!1,[]),"AES",!1,["encrypt","decrypt"]),s=await he.encrypt(he.str2ab(JSON.stringify(this.keys.lockedKey)),o);t(this.#m("/acceptVisitor",{userId:e,encryptedLockedKey:JSON.stringify(s)}))}))}ownerKeyRotation(){throw new Error("ownerKeyRotation() replaced by new budd() approach")}getStorageToken(e){return new Promise(((t,n)=>{this.#m(`/storageRequest?size=${e}`).then((e=>{e.hasOwnProperty("error")&&n(`storage token request error (${e.error})`),t(JSON.stringify(e))})).catch((e=>{n("ChannelApi (getStorageToken) Error [3]: "+c(e))}))}))}budd(e){let{keys:t,storage:n,targetChannel:r}=e??{};return new Promise((async(o,s)=>{e&&e.hasOwnProperty("storage")&&void 0===e.storage&&s("If you omit 'storage' it defaults to Infinity, but you cannot set 'storage' to undefined");try{if(n||(n=1/0),r){if(this.channelId==r)throw new Error("[budd()]: You can't specify the same channel as targetChannel");if(t)throw new Error("[budd()]: You can't specify both a target channel and keys");o(this.#m(`/budd?targetChannel=${r}&transferBudget=${n}`))}else{const e=new ye(t);await e.ready;const r={[ae]:!0,userKeyString:e.userKeyString,channelServer:this.channelServer,channelId:e.hash};let a=await this.#m(`/budd?targetChannel=${r.channelId}&transferBudget=${n}`,r);a.success?o(r):s(JSON.stringify(a))}}catch(e){s(e)}}))}}n([re,oe],ue.prototype,"readyFlag",null),n([re,oe],ue.prototype,"api",null),n([oe],ue.prototype,"updateCapacity",null),n([oe],ue.prototype,"getCapacity",null),n([oe],ue.prototype,"getStorageLimit",null),n([oe],ue.prototype,"getMother",null),n([oe],ue.prototype,"getJoinRequests",null),n([function(e,t,n){if(n&&n.value){const r=n.value;n.value=function(...o){try{return r.call(this,...o)}catch(r){return console.log(`ExceptionReject: ${c(r)}`),console.log(e),console.log(t),console.log(n),new Promise(((e,t)=>t(`Reject: ${c(r)}`)))}}}}],ue.prototype,"isLocked",null),n([oe],ue.prototype,"setMOTD",null),n([oe],ue.prototype,"getAdminData",null),n([oe],ue.prototype,"downloadData",null),n([oe],ue.prototype,"uploadChannel",null),n([oe],ue.prototype,"authorize",null),n([oe],ue.prototype,"postPubKey",null),n([oe],ue.prototype,"storageRequest",null),n([oe],ue.prototype,"lock",null),n([oe],ue.prototype,"acceptVisitor",null),n([oe],ue.prototype,"ownerKeyRotation",null),n([oe],ue.prototype,"budd",null);class pe extends ue{ready;channelSocketReady;#k=!1;#K;#E;#C=this.#B;#A=new Map;#j=!1;#R=()=>{l("L2461","this should never be called")};#_=e=>{l("L2462","this should never be called")};constructor(e,t,n,r){if("object"!=typeof e)throw new Error("ChannelSocket(): first argument must be SBServer or SBChannelHandle");if(h(t,"ChannelSocket(): no onMessage handler provided"),e.hasOwnProperty("channelId")&&e.hasOwnProperty("userKeyString")){const t=e;if(!t.channelServer)throw new Error("ChannelSocket(): no channel server provided (required)");super(t),this.#E=t.channelServer.replace(/^http/,"ws")}else{if(!e.hasOwnProperty("channel_server")||!e.hasOwnProperty("storage_server"))throw new Error("ChannelSocket(): first argument must be SBServer or SBChannelHandle");{const t=e;if(h(t.channel_ws,"ChannelSocket(): no websocket server name provided"),!n)throw new Error("ChannelSocket(): no key provided");if(!r)throw new Error("ChannelSocket(): no channelId provided");super(t,n,r),this.#E=t.channel_ws}}this.#C=t;const o=this.#E+"/api/room/"+this.channelId+"/websocket";this.#K={url:o,ready:!1,closed:!1,timeout:2e3},this.ready=this.channelSocketReady=this.#O()}#B(e){h(!1,"NO MESSAGE HANDLER")}#O(){return o&&console.log("++++ CREATING ChannelSocket.readyPromise()"),new Promise(((e,t)=>{o&&console.log("++++ STARTED ChannelSocket.readyPromise()"),this.#R=e;const n=this.#K.url;o&&(console.log("++++++++ readyPromise() has url:"),console.log(n)),this.#K.websocket||(this.#K.websocket=new WebSocket(this.#K.url)),3===this.#K.websocket.readyState?this.#K.websocket=new WebSocket(n):2===this.#K.websocket.readyState&&(console.warn("STRANGE - trying to use a ChannelSocket that is in the process of closing ..."),this.#K.websocket=new WebSocket(n)),this.#K.websocket.addEventListener("open",(()=>{this.#K.closed=!1,this.channelReady.then((()=>{h(this.userId,"ChannelSocket.readyPromise(): no userId of channel owner/user?"),this.#K.init={userId:this.userId},o&&(console.log("++++++++ readyPromise() constructed init:"),console.log(this.#K.init)),this.#K.websocket.send(JSON.stringify(this.#K.init))}))})),this.#_=this.#I.bind(this),this.#K.websocket.addEventListener("message",this.#_),this.#K.websocket.addEventListener("close",(e=>{this.#K.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?t(`No such channel on this server (${this.channelServer})`):console.log("ChannelSocket() was closed (cleanly): ",e.reason):console.log(`ChannelSocket() was closed (and NOT cleanly: ${e.reason} from ${this.channelServer}`),t("wbSocket() closed before it was opened (?)")})),this.#K.websocket.addEventListener("error",(e=>{this.#K.closed=!0,console.log("ChannelSocket() error: ",e),t("ChannelSocket creation error (see log)")})),setTimeout((()=>{this.#k?o&&(console.log("ChannelSocket() - this socket resolved"),console.log(this)):(console.warn("ChannelSocket() - this socket is not resolving (waited 10s) ..."),console.log(this),t("ChannelSocket() - this socket is not resolving (waited 10s) ..."))}),1e4)}))}async#P(e){let t=e.data;this.#j&&(console.log("... raw unwrapped message:"),console.log(structuredClone(t)));const n=V(t,"L1489");this.#j&&(console.log("... json unwrapped version of raw message:"),console.log(Object.assign({},n))),"function"!=typeof this.#C&&l("ChannelSocket","received message but there is no handler");const r=n;try{const e=Object.entries(r)[0][1];if("encrypted_contents"===Object.keys(e)[0]){o&&console.log("++++++++ #processMessage: received message:",e.encrypted_contents.content);const t=_(await crypto.subtle.digest("SHA-256",(new TextEncoder).encode(e.encrypted_contents.content)));s&&console.log("Received message with hash:",t);const r=this.#A.get(t);r&&(this.#j&&console.log(`++++++++ #processMessage: found matching ack for id ${t}`),this.#A.delete(t),r("success"));const a=Object.entries(n)[0][0],i=e.encrypted_contents.iv;if(i&&p(i)&&16==i.length){e.encrypted_contents.iv=C(i);try{const t=await this.deCryptChannelMessage(a,e.encrypted_contents);if(!t)return;this.#j&&(console.log("++++++++ #processMessage: passing to message handler:"),console.log(Object.assign({},t))),this.#C(t)}catch{console.warn("Error decrypting message, dropping (ignoring) message")}}else console.error("#processMessage: - iv is malformed, should be 16-char b64 string (ignoring)")}else console.warn("++++++++ #processMessage: can't decipher message, passing along unchanged:"),console.log(Object.assign({},r)),this.onMessage(r)}catch(e){console.log(`++++++++ #processMessage: caught exception while decyphering (${e}), passing it along unchanged`),this.onMessage(r)}}#T(e){console.warn("WARNING: firstMessageEventHandler() called recursively (?)"),console.warn(e)}#I(e){this.#j&&console.log("FIRST MESSAGE HANDLER CALLED");const t=this.#T.bind(this);this.#K.websocket.addEventListener("message",t),this.#K.websocket.removeEventListener("message",this.#_);const n=V(e.data,"L2239");o&&console.log("++++++++ readyPromise() received ChannelKeysMessage:",n),h(n.ready,`got roomKeys but channel reports it is not ready [${n}]`),this.motd=n.motd,h(this.readyFlag,"#ChannelReadyFlag is false, parent not ready (?)"),this.locked=n.roomLocked,this.adminData=this.api.getAdminData(),this.#K.websocket.addEventListener("message",this.#P.bind(this)),this.#K.websocket.removeEventListener("message",t),o&&console.log("++++++++ readyPromise() all done - resolving!"),this.#k=!0,this.#R(this)}get status(){if(!this.#K.websocket)return"CLOSED";switch(this.#K.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set onMessage(e){this.#C=e}get onMessage(){return this.#C}set enableTrace(e){this.#j=e,e&&console.log("==== jslib ChannelSocket: Tracing enabled ====")}send(e){let t="string"==typeof e?new ge(this,e):e;return h(this.#K.websocket,"ChannelSocket.send() called before ready"),this.#K.closed&&(this.#j&&console.info("send() triggered reset of #readyPromise() (normal)"),this.ready=this.channelSocketReady=this.#O(),this.#k=!0),new Promise(((e,n)=>{t.ready.then((t=>{this.ready.then((()=>{switch(this.#k||n("ChannelSocket.send() is confused - ready or not?"),this.#K.websocket.readyState){case 1:this.#j&&console.log("++++++++ ChannelSocket.send(): Wrapping message contents:",Object.assign({},t.contents)),he.wrap(t.encryptionKey,JSON.stringify(t.contents),"string").then((r=>{const o=JSON.stringify({encrypted_contents:r,recipient:t.sendToPubKey?t.sendToPubKey:void 0});this.#j&&(console.log("++++++++ ChannelSocket.send(): sending message:"),console.log(r.content.slice(0,100)+"  ...  "+r.content.slice(-100))),crypto.subtle.digest("SHA-256",(new TextEncoder).encode(r.content)).then((t=>{const r=_(t);this.#j&&(console.log("++++++++ ChannelSocket.send():Which has hash:"),console.log(r)),this.#A.set(r,e),this.#K.websocket.send(o),setTimeout((()=>{if(this.#A.has(r)){this.#A.delete(r);const e=`Websocket request timed out (no ack) after ${this.#K.timeout}ms (${r})`;console.error(e),n(e)}else this.#j&&console.log("++++++++ ChannelSocket.send() completed sending"),e("success")}),this.#K.timeout)}))}));break;case 3:case 0:case 2:n("socket not OPEN - either CLOSED or in the state of CONNECTING/CLOSING")}}))}))}))}get exportable_owner_pubKey(){return this.keys.ownerKey}}n([oe],pe.prototype,"onMessage",null),n([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&se.includes(n)&&h(le(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],pe.prototype,"send",null),n([re,oe],pe.prototype,"exportable_owner_pubKey",null);class fe{version="2";#M="b";#D;#x;#$;shardServer;iv;salt;fileName;dateAndTime;fileType;lastModified;actualSize;savedSize;constructor(e){const{version:t,type:n,id:r,key:o,verification:s,iv:a,salt:i,fileName:c,dateAndTime:l,fileType:h,lastModified:y,actualSize:d,savedSize:g}=e;if(n&&(this.#M=n),t)this.version=t;else if(o&&r)if(W(o)&&W(r))this.version="2";else{if(!f(o)||!f(r))throw new Error("Unable to determine version from key and id");this.version="1"}else this.version="2";r&&(this.id=r),o&&(this.key=o),s&&(this.verification=s),this.iv=a,this.salt=i,this.fileName=c,this.dateAndTime=l,this.fileType=h,this.lastModified=y,this.actualSize=d,this.savedSize=g}set id_binary(e){if(!e)throw new Error("Invalid id_binary");if(32!==e.byteLength)throw new Error("Invalid id_binary length");this.#D=e,Object.defineProperty(this,"id64",{get:()=>_(this.#D),enumerable:!1,configurable:!1}),Object.defineProperty(this,"id32",{get:()=>$(this.#D),enumerable:!1,configurable:!1})}set key_binary(e){if(!e)throw new Error("Invalid key_binary");if(32!==e.byteLength)throw new Error("Invalid key_binary length");this.#x=e,Object.defineProperty(this,"key64",{get:()=>_(this.#x),enumerable:!1,configurable:!1}),Object.defineProperty(this,"key32",{get:()=>$(this.#x),enumerable:!1,configurable:!1})}set id(e){if("string"==typeof e){if("1"===this.version){if(!f(e))throw new Error("Requested version 1, but id is not b64");this.id_binary=C(e)}else if("2"===this.version){if(!W(e))throw new Error("Requested version 2, but id is not b62");this.id_binary=U(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid ID type");if(32!==e.byteLength)throw new Error("Invalid ID length");this.id_binary=e}}set key(e){if("string"==typeof e){if("1"===this.version){if(!f(e))throw new Error("Requested version 1, but key is not b64");this.#x=C(e)}else if("2"===this.version){if(!W(e))throw new Error("Requested version 2, but key is not b62");this.#x=U(e)}}else{if(!(e instanceof ArrayBuffer))throw new Error("Invalid key type");if(32!==e.byteLength)throw new Error("Invalid key length");this.#x=e}}get id(){if(h(this.#D,"object handle id is undefined"),"1"===this.version)return _(this.#D);if("2"===this.version)return $(this.#D);throw new Error("Invalid or missing version (internal error, should not happen)")}get key(){if(h(this.#x,"object handle key is undefined"),"1"===this.version)return _(this.#x);if("2"===this.version)return $(this.#x);throw new Error("Invalid or missing version (internal error, should not happen)")}get id64(){throw new Error("Invalid id_binary")}get id32(){throw new Error("Invalid id_binary")}get key64(){throw new Error("Invalid key_binary")}get key32(){throw new Error("Invalid key_binary")}set verification(e){this.#$=e}get verification(){return h(this.#$,"object handle verification is undefined"),this.#$}get type(){return this.#M}}class we{storageServer;constructor(e){if("object"==typeof e)this.storageServer=e.storage_server;else{if("string"!=typeof e)throw new Error("[StorageApi] Invalid parameter to constructor");this.storageServer=e}}#L(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let r=G(e,new Uint8Array(n-t).buffer);return new DataView(r).setUint32(n-4,t),s&&console.log("#padBuf bytes:",r.slice(-4)),r}#H(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const r=new DataView(t).getUint32(0,!0);return r<n&&(s&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=r),s&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}#U(e,t){return new Promise(((n,r)=>{try{he.importKey("raw",e,"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){r(e)}}))}#N(e,t){return new Promise(((n,r)=>{i(this.storageServer+"/api/v1/storeRequest?name="+$(e)+"&type="+t).then((e=>e.arrayBuffer())).then((e=>{const t=X(e);n({salt:new Uint8Array(t.salt),iv:new Uint8Array(t.iv)})})).catch((e=>{console.warn(`**** ERROR: ${e}`),r(e)}))}))}async#F(e,t,n,r,o,s,a){return new Promise((async(i,c)=>{try{const l=await this.#U(n,a),h=await he.encrypt(e,l,s,"arrayBuffer"),y=await o.getStorageToken(h.byteLength),d=await this.storeObject(r,t,s,a,y,h);d.error&&c(`storeObject() failed: ${d.error}`),d.image_id!=t&&c(`received imageId ${d.image_id} but expected ${t}`),i(d.verification_token)}catch(e){const t=`storeObject() failed: ${e}`;console.error(t),c(t)}}))}storeObject(e,t,n,r,o,s){return new Promise(((a,c)=>{if("string"!=typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeData()";console.error(e),c("errMsg")}i(this.storageServer+"/storeData?type="+e+"&key="+t,{method:"POST",body:Z({iv:n,salt:r,image:s,storageToken:(new TextEncoder).encode(o),vid:crypto.getRandomValues(new Uint8Array(48))})}).then((e=>(e.ok||c("response from storage server was not OK"),e.json()))).then((e=>{a(e)})).catch((e=>{c(e)}))}))}storeData(e,t,n){return new Promise(((r,o)=>{if("string"==typeof e){const e="NEW in 1.2.x - storeData() and storeObject() have switched places, you probably meant to use storeObject()";console.error(e),o("errMsg")}e instanceof Uint8Array&&(s&&console.log("converting Uint8Array to ArrayBuffer"),e=new Uint8Array(e).buffer),e instanceof ArrayBuffer||"ArrayBuffer"==e.constructor.name||(s&&console.log("buf must be an ArrayBuffer:"),console.log(e),o("buf must be an ArrayBuffer"));const a=e.byteLength,i=n instanceof ue?n:new ue(n),c=this.#L(e);he.generateIdKey(c).then((e=>{this.#N(e.id_binary,t).then((n=>{const o=$(e.id_binary),s=$(e.key_material),l={[ce]:!0,version:"2",type:t,id:o,key:s,iv:n.iv,salt:n.salt,actualSize:a,verification:this.#F(c,o,e.key_material,t,i,n.iv,n.salt)};r(l)})).catch((e=>o(e)))}))}))}#J(e,t){return new Promise(((n,r)=>{try{let t=V(he.ab2str(new Uint8Array(e)),"L3062");t.error&&r(`#processData() error: ${t.error}`)}catch(e){}finally{const r=X(e);o&&(console.log("Payload (#processData) is:"),console.log(r));const i=new Uint8Array(r.iv),c=new Uint8Array(r.salt),l=t.iv?"string"==typeof t.iv?C(t.iv):t.iv:void 0,h=t.salt?"string"==typeof t.salt?C(t.salt):t.salt:void 0;var a;if(l&&!R(i,l)&&(console.error("WARNING: nonce from server differs from local copy"),console.log(`object ID: ${t.id}`),console.log(` local iv: ${_(l)}`),console.log(`server iv: ${_(r.iv)}`)),h&&!R(c,h)&&(console.error("WARNING: salt from server differs from local copy (will use server)"),t.salt?"string"==typeof t.salt?(console.log("h.salt is in string form (unprocessed):"),console.log(t.salt)):(console.log("h.salt is in arrayBuffer or Uint8Array"),console.log("h.salt as b64:"),console.log(_(t.salt)),console.log("h.salt unprocessed:"),console.log(t.salt)):console.log("h.salt is undefined"),console.log("handleSalt as b64:"),console.log(_(h)),console.log("handleSalt unprocessed:"),console.log(h)),s&&(console.log("will use nonce and salt of:"),console.log(`iv: ${_(i)}`),console.log(`salt : ${_(c)}`)),"1"===t.version)a=C(t.key);else{if("2"!==t.version)throw new Error("Invalid or missing version (internal error, should not happen)");a=U(t.key)}this.#U(a,c).then((e=>{const t=r.image;s&&(console.log("data.image:      "),console.log(r.image),console.log("encrypted_image: "),console.log(t)),he.unwrap(e,{content:t,iv:i},"arrayBuffer").then((e=>{const t=this.#H(e);o&&(console.log("#processData(), unwrapped img: "),console.log(t)),n(t)}))}))}}))}async#W(e,t,n,r){const o={method:"GET"};return new Promise((async(s,a)=>{i(e+t,o).then((e=>e.ok?e.arrayBuffer():null)).then((e=>null===e?null:this.#J(e,n))).then((e=>{null===e&&s(null),s("string"===r?he.ab2str(new Uint8Array(e)):e)})).catch((e=>null))}))}fetchData(e,t="arrayBuffer"){return new Promise((async(n,r)=>{const s=new fe(e);s||r("SBObjectHandle is null or undefined");const a=await s.verification,i=this.storageServer+"/api/v1";o&&console.log("fetchData(), fetching from server: "+i);const c="/fetchData?id="+s.id+"&type="+s.type+"&verification_token="+a,l=await this.#W(i,c,s,t);null!==l?(o&&console.log(`[fetchData] success: fetched from '${i}'`,l),n(l)):r("fetchData() failed")}))}async retrieveImage(e,t,n,r,o,s){console.trace("retrieveImage()"),console.log(e);const a=n||e.previewId,i=r||e.previewKey,c=o||"p",l=s||(e.imgObjVersion?e.imgObjVersion:"2"),y=t.find((e=>e.id&&e.id==a));if(console.log(y),y){h(y.verificationToken,"retrieveImage(): verificationToken missing (?)"),h(y.id,"retrieveImage(): id missing (?)");const e={type:c,version:l,id:y.id,key:i,verification:new Promise(((e,t)=>{y.verificationToken?e(y.verificationToken):t("retrieveImage(): verificationToken missing (?)")}))},t=await this.fetchData(e);return console.log(t),{url:"data:image/jpeg;base64,"+_(t,"b64")}}return{error:"Failed to fetch data - missing control message for that image"}}}class be{channelServer;storageServer;#G;#z=r;constructor(e,t,n){if(console.warn(`==== CREATING Snackabra object generation: ${this.#z} ====`),t&&!0===t&&(o=!0),o&&n&&!0===n&&(s=!0),o&&console.warn("++++ Snackabra constructor ++++ setting DBG to TRUE ++++"),s&&console.warn("++++ Snackabra constructor ++++ ALSO setting DBG2 to TRUE ++++"),"object"==typeof e){const t=e;h(t.channel_server&&t.storage_server,"Snackabra() ERROR: missing channel_server or storage_server"),this.channelServer=t.channel_server,this.storageServer=t.storage_server}else{if("string"!=typeof e)throw new Error("[Snackabra] Invalid parameter type for constructor");this.channelServer=e,this.storageServer="TODO"}this.#G=new we(this.storageServer)}attach(e){return new Promise(((t,n)=>{e.channelId?(e.channelServer?e.channelServer!==this.channelServer&&n("SBChannelHandle channelId does not match channelServer"):e.channelServer=this.channelServer,t(new ue(e))):n("SBChannelHandle missing channelId")}))}create(e,t,n){return new Promise((async(r,o)=>{try{let s,a,c,l;if(e instanceof ye)l=new de("jwk",e.jwk);else{if("object"!=typeof e){const t=`Wrong parameters to create channel: ${e}`;return console.error(t),void o(t)}{const t=e;if(t.channel_server!==this.channelServer){const e=`Channel server mismatch: ${t.channel_server} vs ${this.channelServer}`;return console.error(e),void o(e)}l=n?new de("jwk",n):new de("new")}}s=t instanceof ue?t:void 0,t&&"string"==typeof t&&(c=t),await l.ready,s&&(a=await s.getStorageToken(33554432),a||o("[create channel] Failed to get storage token for the provided channel")),h(l&&l.channelData&&l.channelData.roomId&&l.channelData.ownerKey&&l.channelData.encryptionKey&&l.channelData.signKey&&(a||c),"Unable to determine required parameters");const y={roomId:l?.channelData.roomId,ownerKey:l?.channelData.ownerKey,encryptionKey:l?.channelData.encryptionKey,signKey:l?.channelData.signKey,storageToken:a,SERVER_SECRET:c},d=(new TextEncoder).encode(JSON.stringify(y));let g=await i(this.channelServer+"/api/room/"+y.roomId+"/uploadRoom",{method:"POST",body:d});if(g=await g.json(),!g.success){const e=`Creating channel did not succeed (${JSON.stringify(g)})`;return console.error(e),void o(e)}r({[ae]:!0,channelId:y.roomId,userKeyString:l.userKeyString,channelServer:this.channelServer})}catch(e){const t=`Creating channel did not succeed: ${e}`;console.error(t),o(t)}}))}connect(e,t){const n={[ae]:!0,channelId:e.channelId,userKeyString:e.userKeyString,channelServer:this.channelServer};return o&&console.log("++++ Snackabra.connect() ++++",n),new pe(n,t||(e=>{console.log("MESSAGE (not caught):",e)}))}get storage(){if("string"==typeof this.#G)throw new Error("StorageApi not initialized");return this.#G}get crypto(){return he}get version(){return this.#z}}var ve={Snackabra:be,SBMessage:ge,Channel:ue,SBCrypto:ne,SB384:ye,arrayBufferToBase64:_,sbCrypto:he,version:r};return globalThis.SB||(globalThis.SB=ve),console.warn(`==== SNACKABRA jslib loaded ${globalThis.SB.version} ====`),t})()));