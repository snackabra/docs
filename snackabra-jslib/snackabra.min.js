!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.SB=t():e.SB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,n)=>{for(var a in n)e.o(n,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:n[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Channel:()=>Ne,ChannelSocket:()=>He,KeyPrefix:()=>pe,Memoize:()=>Ce,MessageBus:()=>P,MessageQueue:()=>M,NEW_CHANNEL_MINIMUM_BUDGET:()=>o,Protocol_AES_GCM_256:()=>Fe,Protocol_ECDH:()=>$e,Ready:()=>Be,SB:()=>Ve,SB384:()=>je,SBApiFetch:()=>O,SBChannelKeys:()=>Ue,SBCrypto:()=>ke,SBError:()=>E,SBStorageTokenPrefix:()=>i,Snackabra:()=>qe,StorageApi:()=>ze,_check_SBChannelData:()=>u,_check_SBChannelHandle:()=>h,_check_SBObjectHandle:()=>B,_check_SBStorageToken:()=>c,arrayBufferToBase62:()=>te,arrayBufferToBase64url:()=>z,assemblePayload:()=>ue,b32decode:()=>le,b32encode:()=>ie,b32process:()=>ce,b62regex:()=>W,base62:()=>q,base62ToArrayBuffer:()=>ne,base62ToBase64:()=>ae,base62regex:()=>Q,base64ToArrayBuffer:()=>G,base64ToBase62:()=>se,base64url:()=>N,compareBuffers:()=>R,extractPayload:()=>fe,getRandomValues:()=>L,hydrateKey:()=>be,isBase62Encoded:()=>J,jsonOrString:()=>I,jsonParseWrapper:()=>D,msgTtlToSeconds:()=>b,msgTtlToString:()=>k,sbCrypto:()=>Re,setDebugLevel:()=>S,stringify_SBObjectHandle:()=>K,stripChannelMessage:()=>w,validate_ChannelApiBody:()=>f,validate_ChannelMessage:()=>p,validate_Message:()=>y,validate_SBChannelData:()=>g,validate_SBChannelHandle:()=>d,validate_SBObjectHandle:()=>A,validate_SBStorageToken:()=>l,version:()=>r});var n,a,s=function(e,t,n,a){var s,r=arguments.length,o=r<3?t:null===a?a=Object.getOwnPropertyDescriptor(t,n):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,a);else for(var i=e.length-1;i>=0;i--)(s=e[i])&&(o=(r<3?s(o):r>3?s(t,n,o):s(t,n))||o);return r>3&&o&&Object.defineProperty(t,n,o),o};const r="2.0.0-alpha.5 (build 093)",o=8388608,i="LM2r";function c(e){return e.hash&&"string"==typeof e.hash&&e.hash.length>0&&(!e.size||Number.isInteger(e.size)&&e.size>0)&&(!e.motherChannel||"string"==typeof e.motherChannel)&&(!e.created||Number.isInteger(e.created))&&(!e.used||"boolean"==typeof e.used)}function l(e){if(e){if(e[Ie])return e;if("string"==typeof e&&e.slice(0,4)===i)return{[Ie]:!0,hash:e};if(c(e))return{...e,[Ie]:!0};throw m&&console.error("invalid SBStorageToken ... trying to ingest:\n",e),new E("invalid SBStorageToken")}throw new E("invalid SBStorageToken (null or undefined)")}function h(e){return e.userPrivateKey&&"string"==typeof e.userPrivateKey&&e.userPrivateKey.length>0&&(!e.channelId||"string"==typeof e.channelId&&43===e.channelId.length)&&(!e.channelServer||"string"==typeof e.channelServer)&&(!e.channelData||u(e.channelData))}function d(e){if(e){if(e[Ee])return e;if(h(e))return{...e,[Ee]:!0};throw v&&console.error("invalid SBChannelHandle ... trying to ingest:\n",e),new E("invalid SBChannelHandle")}throw new E("invalid SBChannelHandle (null or undefined)")}function u(e){return e.channelId&&43===e.channelId.length&&e.ownerPublicKey&&"string"==typeof e.ownerPublicKey&&e.ownerPublicKey.length>0&&(!e.storageToken||l(e.storageToken))}function g(e){if(e){if(u(e))return e;throw m&&console.error("invalid SBChannelData ... trying to ingest:\n",e),new E("invalid SBChannelData")}throw new E("invalid SBChannelData (null or undefined)")}function y(e){if(e){if(void 0!==e.body&&null!==e.body&&e.channelId&&"string"==typeof e.channelId&&43===e.channelId.length&&e.sender&&"string"==typeof e.sender&&43===e.sender.length&&e.senderPublicKey&&"string"==typeof e.senderPublicKey&&e.senderPublicKey.length>0&&e.senderTimestamp&&Number.isInteger(e.senderTimestamp)&&e.serverTimestamp&&Number.isInteger(e.serverTimestamp)&&e._id&&"string"==typeof e._id&&75===e._id.length)return e;throw m&&console.error("invalid Message ... trying to ingest:\n",e),new E("invalid Message")}throw new E("invalid Message (null or undefined)")}function f(e){if(e){if(e[Me])return e;if(e.channelId&&43===e.channelId.length&&e.path&&"string"==typeof e.path&&e.path.length>0&&e.userId&&"string"==typeof e.userId&&43===e.userId.length&&e.userPublicKey&&e.userPublicKey.length>0&&(!e.isOwner||"boolean"==typeof e.isOwner)&&(!e.apiPayloadBuf||e.apiPayloadBuf instanceof ArrayBuffer)&&e.timestamp&&Number.isInteger(e.timestamp)&&e.sign&&e.sign instanceof ArrayBuffer)return{...e,[Me]:!0};throw m&&console.error("invalid ChannelApiBody ... trying to ingest:\n",e),new E("invalid ChannelApiBody")}throw new E("invalid ChannelApiBody (null or undefined)")}function p(e){if(e){if(e[Pe])return e;if(!(e.f&&"string"==typeof e.f&&43===e.f.length&&e.c&&e.c instanceof ArrayBuffer&&e.ts&&Number.isInteger(e.ts)&&e.iv&&e.iv instanceof Uint8Array&&12===e.iv.length&&e.s&&e.s instanceof ArrayBuffer)||e.sts&&!Number.isInteger(e.sts)||e.salt&&!(e.salt instanceof ArrayBuffer&&16===e.salt.byteLength)||e._id&&("string"!=typeof e._id||86!==e._id.length)||e.ready&&"boolean"!=typeof e.ready||e.timestampPrefix&&("string"!=typeof e.timestampPrefix||26!==e.timestampPrefix.length)||e.channelId&&("string"!=typeof e.channelId||43!==e.channelId.length)||e.i2&&("string"!=typeof e.i2||!/^[a-zA-Z0-9_]{4}$/.test(e.i2))||!(void 0===e.ttl||Number.isInteger(e.ttl)&&e.ttl>=0&&e.ttl<=15))throw v&&console.error("invalid ChannelMessage ... trying to ingest:\n",e),new E("invalid ChannelMessage");return{...e,[Pe]:!0}}throw new E("invalid ChannelMessage (null or undefined)")}function w(e,t=!1){v&&console.log("stripping message:\n",e);const n={};if(void 0===e.f)throw new E("ERROR: missing 'f' ('from') in message");if(n.f=e.f,void 0===e.c)throw new E("ERROR: missing 'ec' ('encrypted contents') in message");if(n.c=e.c,void 0!==e.iv)n.iv=e.iv;else if(1==!e.stringMessage)throw new E("ERROR: missing 'iv' ('nonce') in message");if(void 0===e.salt)throw new E("ERROR: missing 'salt' in message");if(n.salt=e.salt,void 0!==e.s)n.s=e.s;else if(1==!e.stringMessage)throw new E("ERROR: missing 's' ('signature') in message");if(void 0===e.ts)throw new E("ERROR: missing 'ts' ('timestamp') in message");if(n.ts=e.ts,void 0!==e.sts)n.sts=e.sts;else if(t)throw new E("ERROR: missing 'sts' ('servertimestamp') in message");return void 0!==e.ttl&&15!==e.ttl&&(n.ttl=e.ttl),void 0!==e.t&&(n.t=e.t),void 0!==e.i2&&"____"!==e.i2&&(n.i2=e.i2),n}var m=!1,v=!1;function S(e,t){t&&(v=e&&t),(m=e)&&console.warn("++++ [setDebugLevel]: setting DBG to TRUE ++++"),v&&console.warn("++++ [setDebugLevel]: ALSO setting DBG2 to TRUE (verbose) ++++")}globalThis.configuration&&!0===globalThis.configuration.DEBUG&&((m=!0)&&console.warn("++++ Setting DBG to TRUE based on 'configuration.DEBUG' ++++"),!0===globalThis.configuration.DEBUG2&&(v=!0,m&&console.warn("++++ ALSO setting DBG2 (verbose) ++++")));const b=[0,-1,-1,60,300,1800,14400,129600,864e3,-1,-1,-1,-1,-1,1/0],k=["Ephemeral","<reserved>","<reserved>","One minute","Five minutes","Thirty minutes","Four hours","36 hours","10 days","<reserved>","<reserved>","<reserved>","<reserved>","<reserved>","Permastore (no TTL)"],C="3";if("undefined"==typeof WeakRef){class e{_target;constructor(e){this._target=e}deref(){return this._target}}Object.defineProperty(e.prototype,Symbol.toStringTag,{value:"WeakRef",configurable:!0}),globalThis.WeakRef=e}function B(e){return(!e.version||e.version===C)&&e.id&&"string"==typeof e.id&&43===e.id.length&&(!e.key||"string"==typeof e.key&&43===e.key.length)&&(!e.verification||"string"==typeof e.verification||"object"==typeof e.verification)&&(!e.iv||"string"==typeof e.iv||e.iv instanceof Uint8Array)&&(!e.salt||"string"==typeof e.salt||e.salt instanceof ArrayBuffer)}function A(e){if(e){if(e[Te])return e;if(B(e))return{...e,[Te]:!0};throw m&&console.error("invalid SBObjectHandle ... trying to ingest:\n",e),new E("invalid SBObjectHandle")}throw new E("invalid SBObjectHandle (null or undefined)")}async function K(e){return e.iv&&(e.iv="string"==typeof e.iv?e.iv:te(e.iv)),e.salt&&(e.salt="string"==typeof e.salt?e.salt:te(e.salt)),e.verification=await e.verification,A(e)}class P{bus={};#e(e){return this.bus[e]||(this.bus[e]=[])}subscribe(e,t){this.#e(e).push(t)}unsubscribe(e,t){let n=-1;this.bus[e]?-1!=(n=this.bus[e].findLastIndex((e=>e==t)))?this.bus[e].splice(n,1):console.info("fyi: asked to remove a handler but it's not there"):console.info("fyi: asked to remove a handler but the event is not there")}publish(e,...t){for(const n of this.#e("*"))n(e,...t);for(const n of this.#e(e))n(...t)}}class M{queue=[];resolve=null;reject=null;closed=!1;error=null;enqueue(e){if(m&&console.log(`[MessageQueue] Enqueueing. There were ${this.queue.length} messages in queue`),this.closed)throw new E("[MessageQueue] Error, trying to enqueue to closed queue");this.resolve?(this.resolve(e),this.resolve=null,this.reject=null):this.queue.push(e)}async dequeue(){if(m&&console.log(`[MessageQueue] Dequeueing. There are ${this.queue.length} messages left`),this.queue.length>0){const e=this.queue.shift();return this.closed?Promise.reject(e):(m&&console.log(Le,Le,Le,"[MessageQueue] Dequeueing. Returning item.\n",e,Le),Promise.resolve(e))}return this.closed?null:new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}isEmpty(){return 0===this.queue.length}close(e){this.closed=!0,this.error=e||"close",this.reject&&this.reject(this.error)}async drain(e){for(this.closed||this.close(e||"drain");this.queue.length>0;)m&&console.log(`[MessageQueue] Draining. There are ${this.queue.length} messages left.`),await new Promise((e=>setTimeout(e,0)))}}class E extends Error{constructor(e){if(super(e),this.name=this.constructor.name,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(e).stack,v){let t=null;if(this.stack){const e=this.stack.split("\n");for(let n=1;n<e.length;n++)if(e[n].trim().startsWith("at")){t=`${e[n].trim()}`;break}}null!==t?console.log("\n",Le,"SBError():\n","'"+e+"'","\n",t,"\n",Le):console.log("\n",Le,"SBError():\n",e,"\n",Le)}}}function D(e,t,n){for(;e&&"string"==typeof e;)try{e=JSON.parse(e,n)}catch(n){throw new E(`JSON.parse() error${t?` at ${t}`:""}: ${n}\nString (possibly nested) was: ${e}`)}return e}const T=/^\s*[\[\{].*[\]\}]\s*$/;function I(e){if(null===e)return null;if("string"!=typeof e)return null;if(!T.test(e))return e;try{return JSON.parse(e)}catch(e){return null}}const x=e=>e instanceof ArrayBuffer?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength);function R(e,t){if(typeof e!=typeof t)return!1;if(null==e||null==t)return!1;const n=x(e),a=x(t);if(n.byteLength!==a.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n.getUint8(e)!==a.getUint8(e))return!1;return!0}function L(e){if(e.byteLength<4096)return crypto.getRandomValues(e);{$(!(e.byteLength%1024),"getRandomValues(): large requested blocks must be multiple of 1024 in size");let t=0;try{for(t=0;t<e.byteLength;t+=1024){let n=new Uint8Array(1024);crypto.getRandomValues(n),e.set(n,t)}}catch(e){console.log(`got an error on index i=${t}`),console.log(e),console.trace()}return e}}var _=async function(e,t){const n=new AbortController,a=Symbol("fetch");qe.activeFetches.set(a,n);try{const a=await fetch(e,{...t,signal:n.signal});if(qe.isShutdown)throw await(a.body?.cancel("shutDown")),new E("Fetch aborted (shutDown)");return a}catch(a){if(a instanceof E)throw a;const s=`${a}`;if(-1===s.indexOf("connection closed before message completed")&&-1===s.indexOf("Connection reset by peer")&&-1===s.indexOf("The connection was reset")&&-1===s.indexOf("The server closed the connection")&&-1===s.indexOf("Please try sending the request again."))throw new E(`[SBFetch] Error performing fetch() (this might be normal): ${a}`);console.warn(`... got error ('${s}'), retrying fetch() once again`);try{return await new Promise((a=>{setTimeout((()=>{a(fetch(e,{...t,signal:n.signal}))}),0)}))}catch(e){throw console.error("... got an error on retrying fetch()"),new E(`[SBFetch] Error performing fetch() (after RETRY): ${a}`)}}finally{qe.activeFetches.delete(a)}};async function O(e,t){let n;try{if(n=await _(e,t),!n)throw new E("[SBApiFetch] Server did not respond (might be expected)");if(!n.ok){const e=await n.text();let t="[SBApiFetch] Server responded with error\n";throw n.status&&(t+=`  Status code: ('${n.status}')\n`),n.statusText&&(t+=`  Status text: ('${n.statusText}')\n`),e&&(t+=`  Error msg:   ('${e}')\n`),m&&console.log(t),new E(t)}const s=n.headers.get("content-type");var a;if(!s)throw new E("[SBApiFetch] No content header in server response");if(-1!==s.indexOf("application/json")){const e=await n.json();v&&console.log(`[SBApiFetch] json ('${e}'):\n`,e),a=D(e,"L489")}else{if(-1===s.indexOf("application/octet-stream"))throw-1!==s.indexOf("text/plain")?(a=await n.text(),new E(`[SBApiFetch] Server responded with text/plain (?):\n('${a}')`)):new E(`[SBApiFetch] Server responded with unknown content-type header ('${s}')`);a=fe(await n.arrayBuffer()).payload}if(!a||a.error||!1===a.success){let e="[SBApiFetch] No server response, or cannot parse, or error in response";throw n.status&&(e+=" ["+n.status+"]"),a?.error&&(e+=": "+a.error),v&&console.error("[SBApiFetch] error:\n",e),new E(e)}return v&&console.log("[SBApiFetch] Success:\n",Le,e,"\n",Le,a,"\n",Le),a}catch(e){throw v&&console.error(`[SBApiFetch] caught error: ${e}`),n&&n.body&&!n.body.locked&&(v&&console.log("[SBApiFetch] cancelling response body"),await n.body.cancel()),e instanceof E?e:new E(`[SBApiFetch] caught error: ${e}`)}}function j(e){const t=" *ErrorStart* ",n=" *ErrorEnd* ";return e instanceof E?e:e instanceof Error?(m&&console.error("[WrapError] Error: \n",e),new E(t+e.message+n)):new E(t+String(e)+n)}function F(e,t){throw new E("[_sb_exception] << SB lib error ("+e+": "+t+") >>")}function $(e,t){if(!e){const e=` <<<<[_sb_assert] assertion failed: '${t}'>>>> `;throw m&&console.trace(e),new E(e)}}function U(e,t){const n=new Uint8Array(e.byteLength+t.byteLength);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),n.buffer}const N="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",H=/^([A-Za-z0-9\-_]*)(={0,2})$/;function z(e){const t=e instanceof ArrayBuffer?new Uint8Array(e):e;let n="";for(let e=0;e<t.length;e+=3){const a=t[e],s=t[e+1],r=t[e+2];n+=N[a>>2]+N[(3&a)<<4|s>>4]+(void 0!==s?N[(15&s)<<2|r>>6]:"")+(void 0!==r?N[63&r]:"")}return n}function G(e){if(e=e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""),!H.test(e))throw new E(`invalid character in b64 string (after cleanup: '${e}')`);const t=e.length,n=new Uint8Array(3*t/4);for(let a=0,s=0;a<t;a+=4){const[t,r,o,i]=[e[a],e[a+1],e[a+2],e[a+3]].map((e=>N.indexOf(e)));n[s++]=t<<2|r>>4,-1!==o&&(n[s++]=(15&r)<<4|o>>2),-1!==i&&(n[s++]=(3&o)<<6|i)}return n}const q="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",V=q[0],W=/^[A-Za-z0-9]*$/,Q=W;function J(e){return W.test(e)}const Z=32,Y=new Map,X=new Map;for(let e=1;e<=Z;e++){const t=Math.ceil(8*e/Math.log2(62));Y.set(e,t),X.set(t,e)}const ee=Y.get(Z);function te(e){function t(e,t){let n="",a=0n;for(const t of e)a=a<<8n|BigInt(t);for(;a>0n;a/=62n)n=q[Number(a%62n)]+n;return n.padStart(Y.get(t),V)}if(null==e)throw new E("arrayBufferToBase62: buffer is null or undefined");const n=e instanceof ArrayBuffer?new Uint8Array(e):e;let a="";for(let e,s=n.byteLength,r=0;s>0;r+=e,s-=e)e=s>=Z?Z:s,a+=t(n.slice(r,r+e),e);return a}function ne(e){if(!W.test(e))throw new E("base62ToArrayBuffer32: must be alphanumeric (0-9A-Za-z).");function t(e,t){try{let n=0n,a=new Uint8Array(t);for(let t=0;t<e.length;t++)n=62n*n+BigInt(q.indexOf(e[t]));if(n>2n**BigInt(8*t)-1n)throw new E("base62ToArrayBuffer: Invalid Base62 string.");for(let e=t-1;e>=0;e--,n>>=8n)a[e]=Number(0xffn&n);return a}catch(e){throw new E("base62ToArrayBuffer: Invalid Base62 string.")}}try{let n=0,a=new Uint8Array(6*e.length/8);for(let s,r,o=0;o<e.length;o+=s,n+=r.byteLength)s=Math.min(e.length-o,ee),r=t(e.slice(o,o+s),X.get(s)),a.set(r,n);return a.buffer.slice(0,n)}catch(e){throw e}}function ae(e){return z(ne(e))}function se(e){return te(G(e))}const re="0123456789ADMRTxQjrEywcLBdHpNufk",oe=new RegExp(`[${re}.concat(' ')]`);function ie(e){const t=re;if(e<0||e>524287)throw new Error("Input number is out of range. Expected a 19-bit integer.");let n=[e>>14&31,e>>9&31,e>>4&31,15&e];return n[3]|=16&(n[0]^n[1]^n[2]),n.map((e=>t[e])).join("")}function ce(e){const t={o:"0",O:"0",i:"1",I:"1",l:"1",z:"2",Z:"2",s:"5",S:"5",b:"6",G:"6",a:"9",g:"9",q:"9",m:"M",t:"T",X:"x",J:"j",e:"E",Y:"y",W:"w",C:"c",P:"p",n:"N",h:"N",U:"u",v:"u",V:"u",F:"f",K:"k"};let n="";for(let a of e)n+=t[a]||a;return n}function le(e){if(!oe.test(e))throw new Error(`Input string contains invalid characters (${e}) - use 'process()'.`);let t=Array.from(e).map((e=>re.indexOf(e)));return 16&t.reduce(((e,t)=>e^t))?null:16*(32*(32*t[0]+t[1])+t[2])+(15&t[3])}function he(e){if(null===e)return"0";if(void 0===e)return"u";if(Array.isArray(e))return"a";if(e instanceof ArrayBuffer)return"x";if(e instanceof Uint8Array)return"8";if("boolean"==typeof e)return"b";if(e instanceof DataView)return"v";if(e instanceof Date)return"d";if(e instanceof Map)return"m";if("number"==typeof e)return"number"==typeof(t=e)&&t>=-2147483648&&t<=2147483647&&t%1==0?"i":"n";var t;if(null!==e&&"object"==typeof e&&e.constructor===Object)return"o";if(e instanceof Set)return"t";if("string"==typeof e)return"s";if(e instanceof WeakRef)return"w";if("object"==typeof e&&"function"==typeof e.then)console.error("[getType] Trying to serialize a Promise - did you forget an 'await'?");else{if("object"==typeof e&&"function"==typeof e.toJSON)return"j";console.error("[getType] Unsupported for object:",e)}throw new E("Unsupported type")}function de(e){try{const t={};let n=0,a=0,s=[];for(const r in e)if(e.hasOwnProperty(r)){const o=e[r],i=he(o);switch(i){case"o":const e=de(o);if(!e)throw new E(`Failed to assemble payload for ${r}`);s.push(e);break;case"j":const t=(new TextEncoder).encode(JSON.stringify(o));s.push(t.buffer);break;case"n":const n=new Uint8Array(8);new DataView(n.buffer).setFloat64(0,o),s.push(n.buffer);break;case"i":const a=new Uint8Array(4);new DataView(a.buffer).setInt32(0,o),s.push(a.buffer);break;case"d":const c=new Uint8Array(8);new DataView(c.buffer).setFloat64(0,o.getTime()),s.push(c.buffer);break;case"b":const l=new Uint8Array(1);l[0]=o?1:0,s.push(l.buffer);break;case"s":const h=(new TextEncoder).encode(o);s.push(h);break;case"x":s.push(o);break;case"8":s.push(o.buffer);break;case"m":const d=new Array;o.forEach(((e,t)=>{d.push([t,e])}));const u=de(d);if(!u)throw new E(`Failed to assemble payload for ${r}`);s.push(u);break;case"a":const g=new Array;o.forEach((e=>{g.push(e)}));const y=de(g);if(!y)throw new E(`Failed to assemble payload for ${r}`);s.push(y);break;case"t":const f=new Array;o.forEach((e=>{f.push(e)}));const p=de(f);if(!p)throw new E(`Failed to assemble payload for ${r}`);s.push(p);break;case"w":case"0":case"u":s.push(new ArrayBuffer(0));break;default:throw console.error(`[assemblePayload] Unsupported type: ${i}`),new E(`Unsupported type: ${i}`)}const c=s[s.length-1].byteLength;n++,t[n.toString()]={n:r,s:a,z:c,t:i},a+=c}const r=(new TextEncoder).encode(JSON.stringify(t)),o=new Uint32Array([r.byteLength]);let i=U(new Uint8Array(o.buffer),new Uint8Array(r));for(let e=0;e<s.length;e++)i=U(new Uint8Array(i),s[e]);return i}catch(e){return console.error(e),null}}function ue(e){m&&e instanceof ArrayBuffer&&console.warn("[assemblePayload] Warning: data is already an ArrayBuffer, make sure you are not double-encoding");const t=de({ver003:!0,payload:e});return t?U(new Uint8Array([170,187,187,170]),t):null}function ge(e,t){switch(t){case"o":return ye(e);case"j":return D((new TextDecoder).decode(e),"L1322");case"n":return new DataView(e).getFloat64(0);case"i":return new DataView(e).getInt32(0);case"d":return new Date(new DataView(e).getFloat64(0));case"b":return 1===new Uint8Array(e)[0];case"s":return(new TextDecoder).decode(e);case"a":const n=ye(e);if(!n)throw new E(`Failed to assemble payload for ${t}`);return Object.values(n);case"m":const a=ye(e);if(!a)throw new E(`Failed to assemble payload for ${t}`);const s=new Map;for(const e in a)s.set(a[e][0],a[e][1]);return s;case"t":const r=ye(e);if(!r)throw new E(`Failed to assemble payload for ${t}`);const o=new Set;for(const e in r)o.add(r[e]);return o;case"x":return e;case"8":return new Uint8Array(e);case"0":return null;case"u":return;default:throw new E(`Unsupported type: ${t}`)}}function ye(e){const t="Cannot parse metadata, this is not a well-formed payload";try{const n=new Uint32Array(e.slice(0,4))[0],a=(new TextDecoder).decode(e.slice(4,4+n));let s;try{s=D(a,"L1290")}catch(e){throw new E(t)}const r=4+n,o={};for(let t=1;t<=Object.keys(s).length;t++){const n=t.toString();if(s[n]){const t=s[n],a=t.s,i=t.z,c=t.t,l=e.slice(r+a,r+a+i);o[t.n]=ge(l,c)}else console.log(`found nothing for index ${t}`)}return o}catch(e){if(e instanceof Error&&e.message===t)throw e;throw new E("[extractPayload] exception <<"+e+">> [/extractPayload]")}}function fe(e){const t="Invalid payload signature (this is not a payload)";if(2864429994!==new Uint32Array(e,0,1)[0])throw m&&console.error("\n",Le,t,"\n",e,Le),new E(t);return ye(e.slice(4))}var pe,we;function me(e){"string"==typeof e&&(e=G(e));const t=new Uint8Array(e);return 1==(1&t[t.length-1])?1:0}function ve(e){try{if(e.length<=4)return;const t=e.slice(0,4),n=e.slice(4);switch(t.slice(0,3)){case pe.SBPublicKey:switch(t[3]){case we.Uncompressed:{const e=ne(n);if(96!==e.byteLength)return;const t=e.slice(48,96);return{x:z(e.slice(0,48)),y:z(t),ySign:me(t)}}case we.CompressedEven:case we.CompressedOdd:{const e=t[3]===we.CompressedEven?0:1,a=ne(n);if(48!==a.byteLength)return;const{x:s,y:r}=Oe(z(a),e);return{x:s,y:r,ySign:e}}default:console.error("KeySubPrefix not recognized")}break;case pe.SBPrivateKey:switch(t[3]){case we.Uncompressed:{const e=ne(n);if(144!==e.byteLength)return;const t=e.slice(48,96);return{x:z(e.slice(0,48)),y:z(t),ySign:me(t),d:z(e.slice(96,144))}}case we.CompressedEven:case we.CompressedOdd:{const e=t[3]===we.CompressedEven?0:1,a=ne(n);if(96!==a.byteLength)return;const s=a.slice(0,48),{x:r,y:o}=Oe(z(s),e);return{x:r,y:o,ySign:e,d:z(a.slice(48,96))}}case we.Dehydrated:return void console.error("parseSB384string() - you need to rehydrate first ('hydrateKey()')");default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}return}catch(e){return void console.error("parseSB384string() - malformed input, exception: ",e)}}function Se(e,t,n){if(!e||64!==e.length||!t||64!==t.length||void 0===n)return;const a=new Uint8Array(96);return a.set(G(e),0),a.set(G(t),48),pe.SBPrivateKey+(0===n?we.CompressedEven:we.CompressedOdd)+te(a)}function be(e,t){if(e.length<=4)return;const n=e.slice(0,4);switch(n.slice(0,3)){case pe.SBPublicKey:return e;case pe.SBPrivateKey:switch(n[3]){case we.Uncompressed:case we.CompressedEven:case we.CompressedOdd:return e;case we.Dehydrated:{if(!t)return void console.error("hydrateKey() - you need to provide pubKey to hydrate");const n=z(ne(e.slice(4)).slice(0,48)),a=ve(t);return a&&a.x&&void 0!==a.ySign?Se(a.x,n,a.ySign):void console.error("hydrateKey() - failed to parse public key")}default:console.error("KeySubPrefix not recognized")}break;default:console.error("KeyPrefix not recognized")}}!function(e){e.SBPublicKey="PNk",e.SBPrivateKey="Xj3",e.SBDehydratedKey="XjZ"}(pe||(pe={})),function(e){e.CompressedEven="2",e.CompressedOdd="3",e.Uncompressed="4",e.Dehydrated="x"}(we||(we={}));class ke{generateIdKey(e){if(!(e instanceof ArrayBuffer))throw new TypeError("Input must be an ArrayBuffer");return new Promise(((t,n)=>{try{crypto.subtle.digest("SHA-512",e).then((e=>{const n=e.slice(0,32),a=e.slice(32);t({idBinary:n,keyMaterial:a})}))}catch(e){n(e)}}))}async generateKeys(){try{return await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-384"},!0,["deriveKey"])}catch(e){throw new E("generateKeys() exception ("+e+")")}}async importKey(e,t,n,a,s){try{let r;const o={ECDH:{name:"ECDH",namedCurve:"P-384"},AES:{name:"AES-GCM"},PBKDF2:"PBKDF2"};if("jwk"===e){const e=t;if(void 0===e.kty)throw new E("importKey() - invalid JsonWebKey");"ECDH"===e.alg&&(e.alg=void 0),r=await crypto.subtle.importKey("jwk",e,o[n],a,s)}else r=await crypto.subtle.importKey(e,t,o[n],a,s);return r}catch(r){const o=`... importKey() error: ${r}:`;throw m&&(console.log(Le,Le),console.error(o),console.log(e),console.log(t),console.log(n),console.log(a),console.log(s),console.log(Le,Le)),new E(o)}}async exportKey(e,t){return crypto.subtle.exportKey(e,t).catch((()=>{m&&console.warn("... exportKey() protested, this just means we treat this as undefined")}))}async encrypt(e,t,n){if(null===e)throw new E("no contents");if(!n.iv)throw new E("no nonce");return n.name?$("AES-GCM"===n.name,"Must be AES-GCM (L1951)"):n.name="AES-GCM",crypto.subtle.encrypt(n,t,e)}async wrap(e,t,n,a,s){const r=ue(e),o=crypto.getRandomValues(new Uint8Array(12)),i=await qe.dateNow(),c=new DataView(new ArrayBuffer(8));return c.setFloat64(0,i),{f:t,c:await Re.encrypt(r,n,{iv:o,additionalData:c}),iv:o,salt:a,s:await Re.sign(s,r),ts:i}}sign(e,t){return crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-384"}},e,t)}verify(e,t,n){return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},e,t,n)}str2ab(e){return(new TextEncoder).encode(e)}ab2str(e){return new TextDecoder("utf-8").decode(e)}}function Ce(e,t,n){if(n&&n.get){let a=n.get;n.get=function(){const n=`__${e.constructor.name}__${t}__`;if(this.hasOwnProperty(n))return this[n];{const e=a.call(this);return Object.defineProperty(this,n,{configurable:!1,enumerable:!1,writable:!1,value:e}),e}}}}function Be(e,t,n){if(n&&n.get){let a=n.get;n.get=function(){const n=e.constructor.name,s=e.constructor.ReadyFlag;$(s in this,"'readyFlagSymbol' missing yet getter accessed with @Ready pattern (fatal)"),$(this[s],`'${n}.${t}' getter accessed but object not 'ready' (fatal)`);const r=a.call(this);return $(null!=r,`'${n}.${t}' getter accessed but return value will be NULL (fatal)`),r}}}function Ae(e,t,n){if(n&&n.get){let a=n.get;n.get=function(){const n=e.constructor.name;return"owner"in this&&$(!0===this.owner,`${t} getter or method accessed for object ${n} but callee is not channel owner`),a.call(this)}}}const Ke=["SBMessage","SBObjectHandle","SBChannelHandle","ChannelApiBody"],Pe=Symbol("SB_CHANNEL_MESSAGE_SYMBOL"),Me=Symbol("SB_CHANNEL_API_BODY_SYMBOL"),Ee=Symbol("SBChannelHandle"),De=Symbol.for("SBMessage"),Te=Symbol.for("SBObjectHandle"),Ie=Symbol.for("SBStorageToken");function xe(e,t){switch(t){case"SBMessage":return De in e;case"SBObjectHandle":case"SBChannelHandle":return Te in e;default:return!1}}const Re=new ke,Le="\n"+"=".repeat(76)+"\n",_e="=".repeat(76)+"\n";function Oe(e,t){const n=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),a=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),s=(n+1n)/4n,r=new Uint8Array(G(e)),o="0x"+Array.from(r,(e=>e.toString(16).padStart(2,"0"))).join("");var i=BigInt(o),c=function(e,t,n){if(1n===n)return 0n;let a=1n;for(e%=n;t>0n;)t%2n===1n&&(a=a*e%n),t>>=1n,e=e*e%n;return a}(i*i*i-3n*i+a,s,n);c%2n!==BigInt(t)&&(c=n-c);const l=c.toString(16).padStart(96,"0");return{x:e,y:z(new Uint8Array(l.match(/.{1,2}/g).map((e=>parseInt(e,16)))))}}class je{sb384Ready;static ReadyFlag=Symbol("SB384ReadyFlag");#t;#n;#a;#s;#r;#o;#i;#c;#l;#h;errorState=!1;constructor(e,t){this[je.ReadyFlag]=!1,this.sb384Ready=new Promise((async(n,a)=>{try{if(e)if(e instanceof CryptoKey){const n=await Re.exportKey("jwk",e);$(n&&n.x&&n.y,"INTERNAL"),n.d?(this.#t=!0,this.#r=n.d):(this.#t=!1,$(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#a=n.y}else if(e&&e instanceof Object&&"kty"in e){const n=e;$(n&&n.x&&n.y,"Cannot parse format of JWK key"),e.d?(this.#t=!0,this.#r=n.d):(this.#t=!1,$(!t,"ERROR creating SB384 object: key provided is not the requested private")),this.#n=n.x,this.#a=n.y}else{if("string"!=typeof e)throw new E("ERROR creating SB384 object: invalid key (must be a JsonWebKey, SBUserId, or omitted)");{const n=ve(e);if(!n)throw new E("ERROR creating SB384 object: invalid key (must be a JsonWebKey | SBUserPublicKey | SBUserPrivateKey, or omitted)");const{x:a,y:s,d:r}=n;r?(this.#t=!0,this.#r=r):(this.#t=!1,$(!t,"ERROR creating SB384 object: key provided is not the requested private")),$(a&&s,"INTERNAL"),this.#n=a,this.#a=s}}else{v&&console.log("SB384() - generating new key pair");const e=await Re.generateKeys(),t=await Re.exportKey("jwk",e.privateKey);$(t&&t.x&&t.y&&t.d,"INTERNAL"),this.#t=!0,this.#n=t.x,this.#a=t.y,this.#r=t.d,v&&console.log("#### FROM SCRATCH",this.#t)}if(v&&console.log("SB384() constructor; x/y/d:\n",this.#n,"\n",this.#a,"\n",this.#r),this.#t&&(this.#o=await Re.importKey("jwk",this.jwkPrivate,"ECDH",!0,["deriveKey"])),this.#i=await Re.importKey("jwk",this.jwkPublic,"ECDH",!0,[]),this.#t){const e={...this.jwkPrivate,key_ops:["sign"]};v&&console.log("starting jwk (private):\n",e),this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["sign"])}else{const e={...this.jwkPublic,key_ops:["verify"]};v&&console.log("starting jwk (public):\n",e),this.#c=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:"P-384"},!0,["verify"])}const a=U(G(this.#n),G(this.#a)),s=await crypto.subtle.digest("SHA-256",a);this.#l=te(s);const r=BigInt("0x"+Array.from(new Uint8Array(s)).map((e=>e.toString(16).padStart(2,"0"))).join(""))>>28n;this.#h=Array.from({length:12},((e,t)=>ie(Number(r>>BigInt(19*(11-t))&0x7ffffn)))).join(""),v&&console.log("SB384() constructor; hash:\n",this.#l),this.#s=me(this.#a),v&&console.log("SB384() - constructor wrapping up",this),this[je.ReadyFlag]=!0,n(this)}catch(e){a("ERROR creating SB384 object failed: "+j(e))}}))}get SB384ReadyFlag(){return this[je.ReadyFlag]}get ready(){return this.sb384Ready}get private(){return this.#t}get hash(){return this.#l}get hashB32(){return this.#h}get userId(){return this.hash}get ownerChannelId(){return this.hash}get privateKey(){if(!this.private)throw new E("this is a public key, there is no 'privateKey' value");return this.#o}get signKey(){return this.#c}get publicKey(){return this.#i}get jwkPrivate(){return $(this.#t,"jwkPrivate() - not a private key"),$(this.#n&&this.#a&&this.#r,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:["deriveKey"],kty:"EC",x:this.#n,y:this.#a,d:this.#r}}get jwkPublic(){return $(this.#n&&this.#a,"JWK key info is not available (fatal)"),{crv:"P-384",ext:!0,key_ops:[],kty:"EC",x:this.#n,y:this.#a}}get ySign(){return $(null!==this.#s,"ySign() - ySign is not available (fatal)"),this.#s}get userPublicKey(){return $(this.#n&&void 0!==this.#s,"userPublicKey() - sufficient key info is not available (fatal)"),pe.SBPublicKey+(0===this.#s?we.CompressedEven:we.CompressedOdd)+se(this.#n)}get userPrivateKey(){$(this.#t,"userPrivateKey() - not a private key, there is no userPrivateKey");const e=Se(this.#n,this.#r,this.#s);return $(void 0!==e,"userPrivateKey() - failed to construct key, probably missing info (fatal)"),e}get userPrivateKeyDehydrated(){return $(this.#t&&this.#r,"userPrivateKey() - not a private key, and/or 'd' is missing, there is no userPrivateKey"),pe.SBPrivateKey+we.Dehydrated+se(this.#r)}}s([Ce,Be],je.prototype,"private",null),s([Ce,Be],je.prototype,"hash",null),s([Ce,Be],je.prototype,"hashB32",null),s([Ce,Be],je.prototype,"userId",null),s([Ce,Be],je.prototype,"ownerChannelId",null),s([Ce,Be],je.prototype,"privateKey",null),s([Ce,Be],je.prototype,"signKey",null),s([Ce,Be],je.prototype,"publicKey",null),s([Ce],je.prototype,"jwkPrivate",null),s([Ce],je.prototype,"jwkPublic",null),s([Ce],je.prototype,"ySign",null),s([Ce],je.prototype,"userPublicKey",null),s([Ce],je.prototype,"userPrivateKey",null),s([Ce],je.prototype,"userPrivateKeyDehydrated",null);class Fe{#d;#u;constructor(e,t){this.#u=t,this.#d=this.initializeMasterKey(e)}setChannel(e){}async initializeMasterKey(e){const t=this.#u.salt1,n=this.#u.iterations1,a=this.#u.hash1;$(t&&n&&a,"Protocol_AES_GCM_256.initializeMasterKey() - insufficient key info (fatal)");const s=await crypto.subtle.importKey("raw",(new TextEncoder).encode(e),{name:"PBKDF2"},!1,["deriveBits","deriveKey"]),r=await crypto.subtle.deriveBits({name:"PBKDF2",salt:t,iterations:n,hash:a},s,256);return crypto.subtle.importKey("raw",r,{name:"PBKDF2"},!1,["deriveBits","deriveKey"])}static async genKey(){return{salt1:crypto.getRandomValues(new Uint8Array(16)).buffer,iterations1:1e5,iterations2:1e4,hash1:"SHA-256",summary:"PBKDF2 - SHA-256 - AES-GCM"}}async#g(e){return await crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:this.#u.iterations2,hash:this.#u.hash1},await this.#d,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async encryptionKey(e){return $(e.salt,"Protocol called without salt (Internal Error)"),v&&console.log("CALLING Protocol_AES_GCM_384.encryptionKey(), salt:",e.salt),this.#g(e.salt)}async decryptionKey(e,t){if(t.salt)return m&&console.log("CALLING Protocol_AES_GCM_384.decryptionKey(), salt:",t.salt),this.#g(t.salt);console.warn("Salt should always be present in ChannelMessage")}}class $e{#y;#f=new Map;constructor(){}setChannel(e){this.#y=e}async encryptionKey(e){$(this.#y,"[Protocol_ECDH] Error, need to know channel (L2511)"),await this.#y.ready;const t=this.#y.channelId;$(t,"Internal Error (L2565)");const n=e.t?e.t:this.#y.channelData.ownerPublicKey;return this.#p(t,n,this.#y.privateKey)}async decryptionKey(e,t){await e.ready;const n=e.channelId;$(n,"Internal Error (L2594)");const a=e.visitors.get(t.f);if(a)return this.#p(n,a,e.privateKey);console.error("Protocol_ECDH.key() - sentFrom is unknown")}async#p(e,t,n){const a=e+"_"+t;if(!this.#f.has(a)){const e=await crypto.subtle.deriveKey({name:"ECDH",public:(await new je(t).ready).publicKey},n,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);this.#f.set(a,e),v&&console.log("++++ Protocol_ECDH.key() - newKey:",e)}const s=this.#f.get(a);return $(s,"Internal Error (L2584/2611)"),v&&console.log("++++ Protocol_ECDH.key() - res:",s),s}}class Ue extends je{#w;sbChannelKeysReady;static ReadyFlag=Symbol("SBChannelKeysReadyFlag");#m;channelServer;constructor(e){let t;if(null===e)throw new E("SBChannelKeys constructor: you cannot pass 'null'");if(e)if("string"==typeof e)super(e,!0);else{if(!h(e))throw new E("SBChannelKeys() constructor: invalid parameter (must be SBChannelHandle or SBUserPrivateKey)");{const n=d(e);t=n.channelServer,super(n.userPrivateKey,!0),this.#w=n.channelId,this.#m=n.channelData}}else super();t||(t=qe.defaultChannelServer),"/"===t[t.length-1]&&(this.channelServer=t.slice(0,-1)),this.channelServer=t,this[Ue.ReadyFlag]=!1,this.sbChannelKeysReady=new Promise((async(e,t)=>{try{if(m&&console.log("SBChannelKeys() constructor."),await this.sb384Ready,$(this.private,"Internal Error (L2476)"),this.#w){if(!this.#m){if(!this.channelServer)throw new E("SBChannelKeys() constructor: either key is owner key, or handle contains channelData, or channelServer is provided ...");m&&console.log("++++ SBChannelKeys being initialized from server");var n=await this.callApi("/getChannelKeys");$((n=g(n)).channelId===this.#w,"Internal Error (L2493)"),this.#m=n}}else this.#w=this.ownerChannelId,this.#m={channelId:this.#w,ownerPublicKey:this.userPublicKey};this[Ue.ReadyFlag]=!0,e(this)}catch(e){t("[SBChannelKeys] constructor failed. "+j(e))}}))}get ready(){return this.sbChannelKeysReady}get SBChannelKeysReadyFlag(){return this[Ue.ReadyFlag]}get channelData(){return this.#m}get owner(){return this.private&&this.ownerChannelId&&this.channelId&&this.ownerChannelId===this.channelId}get channelId(){return this.#w}get handle(){return{[Ee]:!0,channelId:this.channelId,userPrivateKey:this.userPrivateKey,channelServer:this.channelServer,channelData:this.channelData}}async buildApiBody(e,t){await this.sb384Ready;const n=await qe.dateNow(),a=new ArrayBuffer(8);new DataView(a).setFloat64(0,n);const s=U(a,(new TextEncoder).encode(e).buffer),r=t?ue(t):void 0,o=await Re.sign(this.signKey,r?U(s,r):s),i={channelId:this.#w,path:e,userId:this.userId,userPublicKey:this.userPublicKey,timestamp:n,sign:o};return r&&(i.apiPayloadBuf=r),f(i)}callApi(e,t){return $(this.channelServer,"[ChannelApi.callApi] channelServer is unknown (you can just set it, eg 'channel.channelServer = ...')"),m&&console.log("ChannelApi.callApi: calling fetch with path:",e),v&&console.log("... and body:",t),$(this.#w&&e,"Internal Error (L2528)"),new Promise((async(n,a)=>{const s={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:ue(await this.buildApiBody(e,t))};v&&console.log("==== ChannelApi.callApi: calling fetch with init:\n",s),O(this.channelServer+"/api/v2/channel/"+this.#w+e,s).then((e=>{n(e)})).catch((e=>{a(e instanceof E?e:"[Channel.callApi] Error: "+j(e))}))}))}}s([Ce,Be],Ue.prototype,"channelData",null),s([Ce,Be],Ue.prototype,"owner",null),s([Ce,Be],Ue.prototype,"channelId",null),s([Ce,Be],Ue.prototype,"handle",null);class Ne extends Ue{channelReady;static ReadyFlag=Symbol("ChannelReadyFlag");locked=!1;static defaultProtocol=new $e;protocol=Ne.defaultProtocol;visitors=new Map;sendQueue=new M;isClosed=!1;constructor(e,t){m&&console.log("Channel() constructor called with handleOrKey:\n",e),null===e?super():super(e),this.protocol=t||Ne.defaultProtocol,this.messageQueueManager().then((()=>{})).catch((e=>{throw e})),this.channelReady=this.sbChannelKeysReady.then((()=>(this.visitors.set(this.channelId,this.channelData.ownerPublicKey),this[Ne.ReadyFlag]=!0,this.protocol.setChannel(this),this))).catch((e=>{throw e}))}get ready(){return $(!this.isClosed,"[Channel] Channel is closed, blocking on'ready' will reject"),this.channelReady}get ChannelReadyFlag(){return this[Ne.ReadyFlag]}get api(){return this}async extractMessage(e){if(e){if(v&&console.log("[extractMessage] Extracting message:",e),e instanceof ArrayBuffer)throw new E("[Channel.extractMessage] Message is an ArrayBuffer (did you forget extractPayload()?)");try{if(!(e=p(e)))return;const t=e.f;if(!t)return void console.error("++++ [extractMessage]: no sender userId hash in message (probably an error)");if(!this.visitors.has(t)){const e=await this.callApi("/getPubKeys");if(!(e&&e instanceof Map))return;for(const[t,n]of e)this.visitors.set(t,n)}$(this.visitors.has(t),`Cannot find sender userId hash ${t} in public key map`),$(this.protocol,"Protocol not set (internal error)");const n=await(this.protocol?.decryptionKey(this,e));if(!n)return void(m&&console.error("++++ [extractMessage]: no decryption key provided by protocol (probably an error)"));if(!e.ts)throw new E("unwrap() - no timestamp in encrypted message");const{c:a,iv:s}=e;$(a,"[unwrap] No contents in encrypted message (probably an error)");const r=new DataView(new ArrayBuffer(8));let o;r.setFloat64(0,e.ts);try{o=await crypto.subtle.decrypt({name:"AES-GCM",iv:s,additionalData:r},n,a)}catch(e){return void(m&&console.error("[extractMessage] Could not decrypt message (exception) [L2898]:",e.message))}e._id||(e._id=Ne.composeMessageKey(this.channelId,e.sts,e.i2)),m&&void 0!==e.ttl&&15!==e.ttl&&console.warn(`[extractMessage] TTL->EOL missing (TTL set to ${e.ttl}) [L2762]`);const i={body:fe(o).payload,channelId:this.channelId,sender:t,senderPublicKey:this.visitors.get(t),senderTimestamp:e.ts,serverTimestamp:e.sts,_id:e._id};return v&&console.log("[Channel.extractMessage] Extracted message (before validation):",i.body),y(i)}catch(e){return void(m&&console.error("[extractMessage] Could not process message (exception) [L2782]:",e.message))}}}async extractMessageMap(e){const t=new Map;for(const[n,a]of e){const e=await this.extractMessage(a);e&&t.set(n,e)}return t}packageMessage(e,t={}){v&&console.log("[Channel#packageMessage] - contents:\n",e,"options:\n",t);let n={f:this.userId,unencryptedContents:e};if(t){if(t.sendTo&&(n.t=t.sendTo),t.subChannel)throw new E("wrapMessage(): subChannel not yet supported");void 0!==t.ttl&&(n.ttl=t.ttl),t.sendString&&($("string"==typeof e,"[packageMessage] sendString is true, but contents is not a string"),$(void 0===t.ttl||0===t.ttl,`[packageMessage] sendString implies TTL=0 (we got ${t.ttl})`),n.ttl=0,n.stringMessage=!0)}return!0!==n.stringMessage&&(n.protocol=t.protocol?t.protocol:this.protocol,void 0===n.ttl&&(n.ttl=15),n.salt||(n.salt=crypto.getRandomValues(new Uint8Array(16)).buffer),n.iv||(n.iv=crypto.getRandomValues(new Uint8Array(12)))),n}async finalizeMessage(e){e.ts||(e.ts=await qe.dateNow()),$(!(!0===e.stringMessage),"[Channel.finalizeMessage()] stringMessage is true, finalizing should not be called (internal error)");const t=ue(e.unencryptedContents);$(t,"wrapMessage(): failed to assemble payload"),$(t.byteLength<65536,`[Channel.finalizeMessage]: body must be smaller than 64 KiB (we got ${t.byteLength/1024} KiB)})`),e.ts=await qe.dateNow();const n=new DataView(new ArrayBuffer(8));return n.setFloat64(0,e.ts),$(e.protocol,"[Channel.finalizeMessage()] Protocol not set (internal error)"),e.c=await Re.encrypt(t,await e.protocol.encryptionKey(e),{iv:e.iv,additionalData:n}),e.s=await Re.sign(this.signKey,e.c),w(e)}#v(e){return new Promise((async(t,n)=>{await this.ready;const a=!0===e.stringMessage?e.unencryptedContents:await this.finalizeMessage(e);await this.callApi("/send",a).then((e=>{t(e)})).catch((e=>{n(e)}))}))}async send(e,t={}){return new Promise((async(n,a)=>{v&&console.log(Le,"[Channel.send] called.",Le,"contents:\n",e);const s=this.packageMessage(e,t);v&&console.log(Le,"packed message:\n",s),this.sendQueue.enqueue({msg:s,resolve:n,reject:a,_send:this.#v.bind(this),retryCount:void 0!==t.retries?t.retries:0}),v&&console.log(_e)}))}create(e,t=this.channelServer){return m&&console.log("==== Channel.create() called with storageToken:",e,"and channelServer:",t),$(null!==e,"[Channel.create] Missing storage token"),t&&(this.channelServer=t),$(this.channelServer,"[Channel.create] Missing channel server (neither provided nor in channelKeys)"),new Promise((async(n,a)=>{await this.channelReady,this.channelData.storageToken=l(e),m&&console.log("Will try to create channel with channelData:",this.channelData),this.callApi("/budd",this.channelData).then((()=>{this.channelServer=t,$(this.channelData&&this.channelData.channelId&&this.userPrivateKey,"Internal Error [L2546]"),n(this)})).catch((e=>{a("Channel.create() failed: "+j(e))}))}))}getLastMessageTimes(){throw new E("Channel.getLastMessageTimes(): deprecated")}getLatestTimestamp(){return this.callApi("/getLatestTimestamp")}async messageQueueManager(){m&&console.log(Le,"[messageQueueManager] Channel message queue is starting up",Le),await this.ready,m&&console.log(Le,"[messageQueueManager] ... continuing to start up",Le);let e=!0;for(;e;)await this.sendQueue.dequeue().then((async t=>{if(v&&console.log(Le,"[messageQueueManager] ... pulled 'msg' from queue:\n",t?.msg.unencryptedContents,Le),t){v&&console.log(Le,"[messageQueueManager] Channel message queue is calling '_send' on message\n",t.msg.unencryptedContents),v&&console.log(t.msg);let e=null;for(;t.retryCount-- >=0;){v&&console.log(Le,"[messageQueueManager] ... trying message send (",t.retryCount,"retries left)\n",t.msg.unencryptedContents,Le);try{const e=await t._send(t.msg);v&&console.log(Le,"[messageQueueManager] Got response from registered '_send':\n",e,Le),t.resolve(e);break}catch(t){v&&console.log(Le,"[messageQueueManager] Got exception from '_send' operation, might retry",t,Le),e="[ERROR] "+t}}t.reject(e)}else v&&console.log("[messageQueueManager] Channel message queue is empty and closed"),e=!1})).catch((e=>{if("shutDown"!==e)throw v&&console.error("[messageQueueManager] Channel message queue is shutting down with error:",e),new E("[messageQueueManager] Channel message queue is shutting down with error: "+e.message);v&&console.log("[messageQueueManager] Channel message queue is shutting down")}))}async close(){m&&console.log("[Channel.close] called (will drain queue)"),this.isClosed=!0,await this.sendQueue.drain("shutDown")}getMessageKeys(e="0"){return new Promise((async(t,n)=>{await this.channelReady,$(this.channelId,"Channel.getMessageKeys: no channel ID (?)");const{keys:a,historyShard:s}=await this.callApi("/getMessageKeys",{prefix:e});m&&console.log("getMessageKeys\n",a),a&&0!==a.size||console.warn("[Channel.getMessageKeys] Warning: no messages (empty/null response); not an error but perhaps unexpected?"),t({keys:a,historyShard:s})}))}getRawMessageMap(e){if(m&&console.log("[getRawMessageMap] called with messageKeys:",e),0===e.size)throw new E("[getRawMessageMap] no message keys provided");return new Promise((async(t,n)=>{await this.channelReady,$(this.channelId,"[getRawMessageMap] no channel ID (?)");const a=await this.callApi("/getMessages",e);$(a,"[getRawMessageMap] no messages (empty/null response)"),v&&console.log(Le,Le,"[getRawMessageMap] - here are the raw ones\n",a,Le,Le),t(a)}))}getMessageMap(e){if(m&&console.log("Channel.getDecryptedMessages() called with messageKeys:",e),0===e.size)throw new E("[getMessageMap] no message keys provided");return new Promise((async(t,n)=>{await this.channelReady;const a=await this.callApi("/getMessages",e),s=new Map;for(const[e,t]of a)try{s.set(e,p(fe(t).payload))}catch(e){m&&console.warn(Le,"[getMessageMap] Failed extract and/or to validate message:",Le,t,Le,e,Le)}t(await this.extractMessageMap(s))}))}getHistory(){return new Promise((async(e,t)=>{await this.channelReady,$(this.channelId,"Channel.getHistory: no channel ID (?)"),e(await this.callApi("/getHistory"))}))}setPage(e){var{page:t,prefix:n,type:a}=e;return $(t,"Channel.setPage: no page (contents) provided"),n=n||12,(a=a||"sb384payloadV3")?this.callApi("/setPage",{page:t,type:a,prefix:n}):this.callApi("/setPage",t)}async getPage(){const e=this.hashB32;m&&console.log(`==== ChannelApi.getPage: calling fetch with: ${e}`);const t=await _(this.channelServer+"/api/v2/page/"+e).catch((e=>{throw new E(`[Channel.getPage] fetch failed: ${e}`)}));if("sb384payloadV3"!==t.headers.get("content-type"))throw new E("[Channel.getPage] Can only handle 'sb384payloadV3' content type, use 'fetch()'");return fe(await t.arrayBuffer()).payload}acceptVisitor(e){return this.callApi("/acceptVisitor",{userId:e})}getCapacity(){return this.callApi("/getCapacity")}getAdminData(){return this.callApi("/getAdminData")}getMother(){return this.getAdminData().then((e=>e.motherChannel))}isLocked(){return this.getAdminData().then((e=>e.locked))}lock(){return this.callApi("/lockChannel")}updateCapacity(e){return this.callApi("/setCapacity",{capacity:e})}getChannelKeys(){return this.callApi("/getChannelKeys")}getPubKeys(){return this.callApi("/getPubKeys")}getStorageLimit(){return this.callApi("/getStorageLimit")}async getStorageToken(e){return l(await this.callApi("/getStorageToken",{size:e}))}budd(e){return new Promise((async(t,n)=>{var{targetChannel:a,size:s}=e||{};if(a){if(this.channelId===a.channelId)return void n(new Error("[budd()]: source and target channels are the same, probably an error"))}else a=(await(new Ne).ready).handle,m&&console.log("\n",Le,"[budd()]: no target channel provided, using new channel:\n",Le,a,"\n",Le);if(s||(s=o),s!==1/0&&Math.abs(s)>await this.getStorageLimit())return void n(new Error(`[budd()]: storage amount (${s}) is more than current storage limit`));const r=a.channelData;if(r)try{r.storageToken=await this.getStorageToken(s),m&&console.log(`[budd()]: requested ${s}, got storage token:`,r.storageToken);const e=await new Ne(a).ready;e.channelServer||(e.channelServer=this.channelServer);const o=g(await e.callApi("/budd",r));if(a.channelId!==o.channelId)return console.warn("[budd()]: target channel ID changed, should not happen, error somewhere\n",Le),console.warn("targetChannel:",a,"\n",Le),console.warn("newChannelData:",o,"\n",Le),void n(new Error("[budd()]: target channel ID changed, should not happen, error somewhere"));o.storageToken||console.warn("[budd()]: target channel has no storage token, possibly an error, should be returned from server");const i={[Ee]:!0,channelId:o.channelId,userPrivateKey:a.userPrivateKey,channelServer:this.channelServer,channelData:o};m&&console.log("[budd()]: success, newHandle:",i),t(d(i))}catch(e){return void n("[budd] Could not get storage token from server, are you sure about the size?")}else n(new Error("[budd()]: target channel has no channel data, probably an error"))}))}static LOWEST_TIMESTAMP="0".repeat(26);static HIGHEST_TIMESTAMP="3".repeat(26);static timestampToBase4String(e){return e.toString(4).padStart(22,"0")+"0000"}static base4stringToDate(e){const t=parseInt(e.slice(0,-4),4);return new Date(t).toISOString()}static getLexicalExtremes(e){if(0===e.size)return[];let t,n=t=e.values().next().value;for(const a of e)a<t&&(t=a),a>n&&(n=a);return[t,n]}static messageKeySetToPrefix=e=>{if(0===e.size)return"0";const[t,n]=Ne.getLexicalExtremes(e);$(t&&n,"[timestampLongestPrefix]: no lowest or highest (internal error?)");const{timestamp:a}=Ne.deComposeMessageKey(t),{timestamp:s}=Ne.deComposeMessageKey(n);let r=0;for(;r<a.length&&r<s.length&&a[r]===s[r];)r++;return a.substring(0,r)};static timestampLongestPrefix=(e,t)=>{if(e&&t&&"string"==typeof e&&"string"==typeof t&&26===e.length&&26===t.length){let n=0;for(;n<e.length&&n<t.length&&e[n]===t[n];)n++;return e.substring(0,n)}throw new E(`[timestampLongestPrefix]: invalid input:\n '${e}' or '${t}'`)};static timestampRegex=/^[0-3]{26}$/;static base4StringToTimestamp(e){return e&&"string"==typeof e&&26===e.length&&Ne.timestampRegex.test(e)?parseInt(e.slice(0,-4),4):0}static base4StringToDate(e){const t=Ne.base4StringToTimestamp(e);return t?new Date(t).toISOString():""}static deComposeMessageKey(e){const t=e.match(/^([a-zA-Z0-9]{43})_([_a-zA-Z0-9]{4})_([0-3]{26})$/);return t&&t.length>=4?{channelId:t[1],i2:t[2],timestamp:t[3]}:{channelId:"",i2:"",timestamp:""}}static composeMessageKey(e,t,n="____"){return`${e}_${n??"____"}_${Ne.timestampToBase4String(t)}`}}s([Ce,Be],Ne.prototype,"api",null),s([Be],Ne.prototype,"getLatestTimestamp",null),s([Be,Ae],Ne.prototype,"setPage",null),s([Be],Ne.prototype,"getPage",null),s([Be,Ae],Ne.prototype,"acceptVisitor",null),s([Be,Ae],Ne.prototype,"getCapacity",null),s([Be,Ae],Ne.prototype,"getAdminData",null),s([Be,Ae],Ne.prototype,"getMother",null),s([Be,Ae],Ne.prototype,"isLocked",null),s([Be,Ae],Ne.prototype,"lock",null),s([Be,Ae],Ne.prototype,"updateCapacity",null),s([Be,Ce],Ne.prototype,"getChannelKeys",null),s([Be],Ne.prototype,"getPubKeys",null),s([Be],Ne.prototype,"getStorageLimit",null),s([Be],Ne.prototype,"getStorageToken",null),s([Be,Ae],Ne.prototype,"budd",null);class He extends Ne{channelSocketReady;static ReadyFlag=Symbol("ChannelSocketReadyFlag");#S;#b;onMessage=e=>{$(!1,"[ChannelSocket] NO MESSAGE HANDLER")};#k=new Map;#C=new Map;#B=!1;lastTimestampPrefix="0".repeat(26);#A=0;constructor(e,t,a){if($(t,"[ChannelSocket] constructor: no onMessage handler provided"),"string"==typeof e)super(e,a);else{const t=d(e);super(t,a),t.channelServer&&(this.channelServer=t.channelServer)}this.channelServer||(this.channelServer=qe.defaultChannelServer),this[n.ReadyFlag]=!1,this.#b=this.channelServer.replace(/^http/,"ws"),this.onMessage=t,this.channelSocketReady=this.#K()}#P(){this.#A=setInterval((()=>{this.isClosed?console.error("[ChannelSocket] we are closed, removing ping interval"):qe.haveNotHeardFromServer()}),500),this.#S.websocket.send("ping")}#K(){return new Promise((async(e,t)=>{m&&console.log("++++ STARTED ChannelSocket.readyPromise()"),await this.sbChannelKeysReady;const a=this.#b+"/api/v2/channel/"+this.channelId+"/websocket";if(this.#S={url:a,ready:!1,closed:!1,timeout:2e4},!this.#S.websocket||3===this.#S.websocket.readyState||2===this.#S.websocket.readyState){this.#S.websocket&&(console.warn("[ChannelSocket] websocket is in a bad state, closing it ... will await"),await async function(e){console.log("[closeSocket] closing socket",e),e.readyState!==WebSocket.CLOSED?await new Promise((t=>{e.addEventListener("close",(()=>{console.log("[Snackabra.closeSocket] ... socket confirmed closed",e),t()}),{once:!0}),e.close(1e3)})):console.warn("[Snackabra] websocket already closed")}(this.#S.websocket),qe.addChannelSocket(this));const e=ue(await this.buildApiBody(a));$(e,"Internal Error [L3598]"),this.#S.websocket=new WebSocket(a+"?apiBody="+te(e)),qe.addChannelSocket(this)}m&&console.log(Le,"++++ readyPromise() - setting up websocket message listener",Le);const s=this.#S.websocket,r=async a=>{a.data||(m&&console.error("[ChannelSocket] received empty message"),t("[ChannelSocket] received empty message (should be a 'ready' message)"));let o=null;if("string"==typeof a.data?o=D(a.data,"L3909"):a.data instanceof ArrayBuffer?o=fe(a.data).payload:a.data instanceof Blob?o=fe(await a.data.arrayBuffer()).payload:F("L3987","[ChannelSocket] received something other than string or ArrayBuffer"),o)o.ready?(m&&console.log("++++ readyPromise() - received ready message, switching to main message processor:\n",a.data),o.latestTimestamp?(this.lastTimestampPrefix=o.latestTimestamp,v&&console.log("++++ readyPromise() - received latestTimestamp:",this.lastTimestampPrefix)):console.warn("[ChannelSocket] received 'ready' message without 'latestTimestamp'"),s.removeEventListener("message",r),s.addEventListener("message",this.#M),this.#P(),this[n.ReadyFlag]=!0,e(this)):t("[ChannelSocket] received something other than 'ready' as first message:\n"+JSON.stringify(a.data));else{const e="[ChannelSocket] received empty message, or could not parse it (should be a 'ready' message)";m&&console.error(e),t(e)}};this.#S.websocket.addEventListener("message",r);let o=setTimeout((()=>{if(this[n.ReadyFlag])v&&console.log("[ChannelSocket] resolved correctly",this);else{const e="[ChannelSocket] Socket not resolving after waiting, fatal.";console.warn(e),t(e)}}),2e3);this.#S.websocket.addEventListener("open",(async()=>{this.#S.closed=!1,o&&(clearTimeout(o),o=void 0),await this.ready,m&&console.log("++++++++ readyPromise() sending init"),this.#S.websocket.send("ready"),m&&console.log("++++++++ readyPromise() ... no immediate errors for init")})),this.#S.websocket.addEventListener("close",(e=>{this.#S.closed=!0,e.wasClean?e.reason.includes("does not have an owner")?t(`No such channel on this server (${this.channelServer})`):console.log("[ChannelSocket] Closed (cleanly), with reason: ",e.reason):console.log(`[ChannelSocket] closed but NOT cleanly: ${e.reason} from ${this.channelServer}`),t("wbSocket() closed before it was opened (?)")})),this.#S.websocket.addEventListener("error",(e=>{this.#S.closed=!0,m&&console.log("[ChannelSocket] Error: ",e),t("[ChannelSocket] Websocket error event "+e)}))}))}#M=async e=>{$(!this.errorState,"[ChannelSocket] in error state (Internal Error L4018)");const t=e.data;v&&console.log(Le,"[ChannelSocket] Received socket message:\n",t,Le);var n=null;if($(t,"[ChannelSocket] received empty message"),qe.heardFromServer(),"string"==typeof t){const e=I(t);return e||F("L3287","[ChannelSocket] Cannot parse message: "+t),"string"==typeof e?Ne.timestampRegex.test(e)?(v&&console.log("[ChannelSocket] Received 'latestTimestamp' message:",e),qe.heardFromServer(),e>this.lastTimestampPrefix&&this.#S.websocket.send(this.lastTimestampPrefix),void setTimeout((()=>{this.#S.closed||(v&&console.log("[ChannelSocket] Sending 'ping' (timestamp request) message."),this.#S.websocket.send("ping"))}),1e3)):(v&&console.log("[ChannelSocket] Received simple string message, will forward\n",e),void this.onMessage(e)):(m&&console.log("[ChannelSocket] Received unrecognized 'string' message, will discard:\n",e),void this.#S.websocket.send(ue({error:`Cannot parse 'string' message (''${e})`})))}if(t instanceof ArrayBuffer)n=fe(t).payload;else{if(!(t instanceof Blob))return void this.#S.websocket.send(ue({error:"Received unknown 'type' of message (??)"}));n=fe(await t.arrayBuffer()).payload}if($(n,"[ChannelSocket] cannot extract message"),n.ready)return void(m&&console.log("++++++++ #processMessage: received ready message\n",n));if(n.error)return void console.error("++++++++ #processMessage: received error message\n",n);n=p(n),v&&console.log(Le,"[ChannelSocket] Received (extracted/validated) socket message:\n",n,"\n",Le),n.channelId||(n.channelId=this.channelId),$(n.channelId===this.channelId,"[ChannelSocket] received message for wrong channel?"),this.#B&&console.log("[ChannelSocket] Received socket message:",n),$(n.c&&n.c instanceof ArrayBuffer,"[ChannelSocket] Internal Error (L3675)");const a=z(await crypto.subtle.digest("SHA-256",n.c));m&&console.log("[ChannelSocket] Received message with hash:",a);const s=this.#k.get(a);s&&((m||this.#B)&&console.log(`++++++++ #processMessage: found matching ack for id ${a}`),this.#k.delete(a),s("success"));const r=this.#C.get(a);r&&((v||this.#B)&&console.log(`++++++++ #processMessage: clearing matching ack timeout for id ${a}`),clearTimeout(r),this.#C.delete(a)),v&&console.log("[ChannelSocket] New message, client andserver time stamp: ",n.sts);const o=await this.extractMessage(n);o?(m&&console.log("[ChannelSocket] Repackaged and will deliver 'Message':",o),this.onMessage(o)):m&&console.log("[ChannelSocket] Message could not be parsed, will not deliver")};get ready(){return $(!this.errorState,"[ChannelSocket] in error state (Internal Error L4104)"),$(!this.isClosed,"[ChannelSocket] We are closed, blocking on'ready' will reject"),this.channelSocketReady}get ChannelSocketReadyFlag(){return this[n.ReadyFlag]}get status(){if(!this.#S||!this.#S.websocket)return"CLOSED";switch(this.#S.websocket.readyState){case 0:return"CONNECTING";case 1:return"OPEN";case 2:return"CLOSING";default:return"CLOSED"}}set enableTrace(e){this.#B=e,e&&console.log("==== jslib ChannelSocket: Tracing enabled ====")}#v(e){return $(!this.errorState,"[ChannelSocket] in error state (Internal Error L4130)"),v&&console.log("[ChannelSocket] #_send() called"),new Promise((async(t,n)=>{if(v&&console.log(Le,"++++++++ [ChannelSocket.#_send()] called, will return promise to send:",e.unencryptedContents,Le),this.#S.closed)return v&&console.error("[ChannelSocket] #_send() to a CLOSED socket"),void n("<websocket closed>");if(!0===e.stringMessage)try{const n=e.unencryptedContents;v&&console.log("[ChannelSocket] actually sending string message:",n),this.#S.websocket.send(n),t("success")}catch(e){return void n(`<websocket error upon send() of a string message: ${e}>`)}else{const a=ue(e=await this.finalizeMessage(e));if(!a)return void n("ChannelSocket.send(): no message payload (Internal Error)");const s=z(await crypto.subtle.digest("SHA-256",e.c));(v||this.#B)&&console.log("++++++++ ChannelSocket.send(): Which has hash:",s),this.#k.set(s,t),this.#C.set(s,setTimeout((async()=>{if(this.#k.has(s))return this.#k.delete(s),qe.isShutdown?void n("shutDown"):(m&&console.error(`[ChannelSocket] websocket request timed out (no ack) after ${this.#S.timeout}ms (${s})`),void n(`<websocket request timed out (no ack) after ${this.#S.timeout}ms (${s})>`));(m||this.#B)&&console.log("++++++++ ChannelSocket.send() completed sending"),t("<received ACK, success, message sent and mirrored back>")}),this.#S.timeout)),v&&console.log("[ChannelSocket] actually sending message:",a);try{v&&console.log("[ChannelSocket] actually sending message:",a),this.#S.websocket.send(a)}catch(e){return console.error("Failed to send on socket:\n",e,"\n",(new Error).stack),void n(`<websocket error upon send() of a message: ${e}>`)}}}))}async send(e,t){return v&&console.log("++++ ChannelSocket.send() called ..."),await this.ready,$(this.#S&&this.#S.websocket,"[ChannelSocket.send()] called before ready"),v&&console.log(Le,"[ChannelSocket] sending, contents:\n",JSON.stringify(e),Le),this.#S.closed&&(this.#B&&console.info("send() triggered reset of #readyPromise() (normal)"),this.channelSocketReady=this.#K(),this[n.ReadyFlag]=!1),new Promise((async(n,a)=>{this.ChannelSocketReadyFlag||a("ChannelSocket.send() is NOT ready, perhaps it's resetting?");const s=this.#S.websocket.readyState;switch(s){case 1:this.sendQueue.enqueue({msg:this.packageMessage(e,t),resolve:n,reject:a,_send:this.#v.bind(this),retryCount:3});break;case 0:case 2:case 3:a("[ChannelSocket.send()] Tried sending but socket not OPEN - it is "+(0===s?"CONNECTING":2===s?"CLOSING":"CLOSED"));break;default:F("ChannelSocket",`socket in unknown state (${s})`)}}))}reset(){this.#S&&this.#S.websocket&&(1===this.#S.websocket.readyState&&this.#S.websocket.close(),this.#S.closed=!0,qe.removeChannelSocket(this),this.channelSocketReady=this.#K())}async close(){m&&console.log("++++ ChannelSocket.close() called ... closing down stuff ..."),this.isClosed=!0,clearInterval(this.#A),this.#S&&this.#S.websocket&&1===this.#S.websocket.readyState&&this.#S.websocket.send("close"),await super.close(),qe.removeChannelSocket(this),this[n.ReadyFlag]=!1}}n=He,s([function(e,t,n){if(n&&n.value){const e=n.value;n.value=function(...t){for(let e of t){const t=e.constructor.name;"string"==typeof(n=t)&&Ke.includes(n)&&$(xe(e,t),`invalid parameter: ${e} (expecting ${t})`)}var n;return e.call(this,...t)}}}],He.prototype,"send",null);class ze{#E;constructor(e){this.#E=Promise.resolve(e).then((e=>{const t=e;return $("string"==typeof t,"StorageApi() constructor requires a string (for storageServer)"),t}))}async getStorageServer(){return this.#E}static padBuf(e){const t=e.byteLength;let n;n=t+4<4096?4096:t+4<1048576?2**Math.ceil(Math.log2(t+4)):1048576*Math.ceil((t+4)/1048576);let a=U(e,new Uint8Array(n-t).buffer);return new DataView(a).setUint32(n-4,t),v&&console.log("padBuf bytes:",a.slice(-4)),a}#D(e){const t=e.slice(-4);var n=new DataView(t).getUint32(0);const a=new DataView(t).getUint32(0,!0);return a<n&&(v&&console.warn("#unpadData - size of shard encoded as little endian (fixed upon read)"),n=a),v&&console.log(`#unpadData - size of object is ${n}`),e.slice(0,n)}static getObjectKey(e,t){return new Promise(((n,a)=>{try{Re.importKey("raw",e,"PBKDF2",!1,["deriveBits","deriveKey"]).then((e=>{crypto.subtle.deriveKey({name:"PBKDF2",salt:t,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]).then((e=>{n(e)}))}))}catch(e){a(e)}}))}async storeData(e,t){try{const n=ue(e);if(!n)throw new E("[storeData] failed to assemble payload");const s=n.byteLength,r=a.padBuf(n),o=await Re.generateIdKey(r),i=await this.getStorageServer(),d=i+"/api/v2/storeRequest?id="+te(o.idBinary),u=await O(d);if(!u.salt||!u.iv)throw new E("[storeData] Failed to get key info (salt, nonce) from storage server");const g=te(o.idBinary),y=await a.getObjectKey(o.keyMaterial,u.salt),f=await Re.encrypt(r,y,{iv:u.iv});let p;if(t instanceof Ne)p=await t.getStorageToken(f.byteLength);else if(h(t))p=await(await new Ne(t).ready).getStorageToken(f.byteLength);else{if(!c(t))throw new E("[storeData] invalid budget source (needs to be a channel, channel handle, or storage token)");p=l(t)}const w=i+"/api/v2/storeData?id="+g,v={method:"POST",headers:{"Content-Type":'application/octet-stream"'},body:ue({id:g,iv:u.iv,salt:u.salt,storageToken:p,data:f})};console.log("5555 5555 [storeData] storeQuery:",Le,w,Le);const S=await O(w,v),b={[Te]:!0,version:C,id:g,key:te(o.keyMaterial),iv:u.iv,salt:u.salt,actualSize:s,verification:S.verification,storageServer:i};return m&&console.log("storeData() - success, handle:",b,f),b}catch(e){if(console.error("[storeData] failed:",e),e instanceof E)throw e;throw new E(`[storeData] failed to store data: ${e}`)}}async#T(e,t,n){try{let s=await O(e+t,{method:"GET"});s=function(e){if(e){if("3"===e.version&&"string"==typeof e.id&&43===e.id.length&&W.test(e.id)&&e.iv instanceof Uint8Array&&12===e.iv.byteLength&&e.salt instanceof ArrayBuffer&&16===e.salt.byteLength&&e.data instanceof ArrayBuffer&&e.actualSize===e.data.byteLength)return e;throw new E("invalid Shard")}throw new E("invalid SBObjectHandle (null or undefined)")}(s),$(n.key,"object handle 'key' is missing, cannot decrypt"),n.iv=s.iv,n.salt=s.salt,n.data=new WeakRef(s.data),n.actualSize=s.actualSize,v&&console.log("fetchData(), handle (and data) at this point:",n,s.data);const r=ne(n.key),o=await a.getObjectKey(r,n.salt),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:n.iv},o,s.data),c=this.#D(i);return v&&console.log("shard.data (decrypted and unpadded):",c),n.payload=fe(c).payload,n.data=new WeakRef(s.data),n}catch(t){return m&&console.log(`fetchData(): trying to get object on '${e}' failed: '${t}'`),null}}async fetchData(e){const t=A(e);if(m&&console.log("fetchData(), handle:",t),t.data&&t.data instanceof WeakRef&&t.data.deref())return t;const n=await t.verification,a=t.storageServer?t.storageServer:null,s=await this.getStorageServer();for(const e of[a,"http://localhost:3841",s]){if(!e)continue;m&&console.log("\n",Le,"fetchData(), trying server: ",e,"\n",Le);const a="/api/v2/fetchData?id="+t.id+"&verification="+n,s=await this.#T(e,a,t);if(null!==s)return m&&console.log(`[fetchData] success: fetched from '${e}'`,s),s.storageServer=e,s}throw new E("[fetchData] failed to fetch from any server")}static getData(e){const t=A(e);if(t.data){if(t.data instanceof WeakRef){return t.data.deref()||void 0}if(t.data instanceof ArrayBuffer)return t.data;throw new E("Invalid data type in handle")}}static getPayload(e){const t=A(e);if(t.payload)return t.payload;const n=a.getData(t);if(!n)throw new E("[getPayload] no data or payload in handle, use fetchData()");return fe(n).payload}}a=ze,s([Ce],ze.prototype,"getStorageServer",null);class Ge{static events={};static on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}static off(e,t){if(!this.events[e])return;const n=this.events[e].indexOf(t);n>-1&&this.events[e].splice(n,1)}static emit(e,...t){const n=this.events[e];n&&0!==n.length&&n.forEach((e=>e(...t)))}}class qe extends Ge{#I;#x;#R=r;#L;static lastTimeStamp=0;static activeFetches=new Map;static#_=new Set;static isShutdown=!1;static lastTimestampPrefix="0".repeat(26);static#O=Date.now();static onlineStatus="unknown";static defaultChannelServer="http://localhost:3845";constructor(e,t){super(),console.warn(`==== CREATING Snackabra object generation: ${this.#R} ====`),$("string"==typeof e,"[Snackabra] Takes channel server URL as parameter"),e&&(qe.defaultChannelServer=e),"boolean"==typeof t&&(t={DEBUG:t}),t&&t.DEBUG&&!0===t.DEBUG&&(m=!0),t&&m&&t.DEBUG2&&!0===t.DEBUG2&&(v=!0),m&&console.warn("++++ Snackabra constructor: setting DBG to TRUE ++++"),v&&console.warn("++++ Snackabra constructor: ALSO setting DBG2 to TRUE (verbose) ++++"),t&&t.sbFetch&&(console.log("++++ Snackabra constructor: setting custom fetch function ++++"),_=t.sbFetch),this.#I=e,this.#x=new ze(new Promise(((e,t)=>{m&&console.log(`++++ Snackabra constructor: fetching storage server name from '${this.#I+"/api/v2/info"}' ++++`),O(this.#I+"/api/v2/info").then((t=>{m&&console.log("Channel server info:",t),$(t.storageServer,"Channel server did not provide storage server name, cannot initialize"),this.#L=t,m&&console.log("Channel server info:",this.#L),e(t.storageServer)})).catch((e=>{qe.isShutdown||(console.error("[Snackabra] fetching storage server name failed (fatal):\n",e),t(e))}))})))}static async dateNow(){let e=Date.now();return e<=qe.lastTimeStamp&&(e=qe.lastTimeStamp+1),qe.lastTimeStamp=e,e}static heardFromServer(){switch(qe.#O=Date.now(),qe.onlineStatus){case"offline":m&&console.info("[Snackabra] We are BACK online"),this.emit("online"),this.emit("reconnected"),qe.onlineStatus="online";break;case"online":break;case"unknown":m&&console.info("[Snackabra] We are now ONLINE"),this.emit("online"),qe.onlineStatus="online"}this.checkUnknownNetworkStatus()}static checkUnknownNetworkStatus(){0===qe.#_.size&&("unknown"!==qe.onlineStatus&&this.emit("unknownNetworkStatus"),qe.onlineStatus="unknown")}static haveNotHeardFromServer(){Date.now()-qe.#O>1100&&"online"===qe.onlineStatus&&(qe.#_.size>0?(m&&console.warn("[Snackabra] OFFLINE"),qe.onlineStatus="offline",this.emit("offline")):(m&&console.warn("[Snackabra] No active channel sockets, online status is now UNKNOWN"),qe.onlineStatus="unknown",qe.onlineStatus="offline",this.emit("unknownNetworkStatus"))),this.checkUnknownNetworkStatus()}static addChannelSocket(e){qe.#_.add(e)}static removeChannelSocket(e){qe.#_.has(e)&&qe.#_.delete(e),this.checkUnknownNetworkStatus()}async getPage(e){return m&&console.log(`==== Snackabra.getPage: calling fetch with: ${e}`),fe(await O(this.#I+"/api/v2/page/"+e))}create(e){return $(null!==e,"[create channel] Invalid parameter (null)"),new Promise((async(t,n)=>{try{var a;if(e instanceof Ne){const t=e;await t.ready,t.channelServer||(t.channelServer=this.#I),a=await t.getStorageToken(o)}else try{a=l(e)}catch(e){return void n("Invalid parameter to create() - need a token or a budget channel")}$(a,"[create channel] Failed to get storage token for the provided channel");const s=await(new Ne).ready;s.channelServer=this.#I,s.create(a).then((e=>{t(e.handle)})).catch((e=>{n(e)}))}catch(e){const t=`Creating channel did not succeed: ${e}`;console.error(t),n(t)}}))}connect(e,t){let n;if(n="string"==typeof e?{userPrivateKey:e}:e,$(n&&n.userPrivateKey,"[Snackabra.connect] Invalid parameter (at least need owner private key)"),n.channelServer&&n.channelServer!==this.#I)throw new E(`[Snackabra.connect] channel server in handle ('${n.channelServer}') does not match what SB was set up with ('${this.#I}')`);return n.channelServer||(n.channelServer=this.#I),m&&console.log("++++ Snackabra.connect() ++++",n),t?new He(n,t):new Ne(n)}static async closeAll(){console.log(Le,"==== Snackabra.closeAll() called ====",Le),qe.isShutdown?console.warn("closeAll() called, but it was already shutting down"):(qe.isShutdown=!0,qe.activeFetches.forEach((e=>e.abort("Snackabra.closeAll() called"))),qe.activeFetches.clear(),await Promise.all(Array.from(qe.#_).map(close)),console.log("... waiting for everything to close ..."),await new Promise((e=>setTimeout(e,2e3))))}get storage(){return this.#x}async getStorageServer(){return this.#x.getStorageServer()}get crypto(){return Re}get version(){return this.#R}}s([Ce],qe.prototype,"storage",null),s([Ce],qe.prototype,"getStorageServer",null);var Ve={Snackabra:qe,Channel:Ne,SBCrypto:ke,SB384:je,arrayBufferToBase64url:z,base64ToArrayBuffer:G,arrayBufferToBase62:te,base62ToArrayBuffer:ne,sbCrypto:Re,version:r,setDebugLevel:S};return globalThis.SB||(globalThis.SB=Ve),console.warn(`==== SNACKABRA jslib (re)loaded, version '${globalThis.SB.version}' ====`),t})()));